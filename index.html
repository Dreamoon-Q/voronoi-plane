<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>Voronoi Plane</title>
    <script src="https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/d3-delaunay@6"></script>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+TC:wght@400;700&family=Noto+Serif+TC:wght@700&family=Bangers&family=Pacifico&family=Lobster&family=Montserrat:wght@400;700;900&family=Caveat&family=Russo+One&display=swap" rel="stylesheet">

    <style>
        :root { 
            --bg-color: #0f0f0f; 
            --panel-bg: #1a1a1a; 
            --accent: #FFD700; 
            --text: #f1f1f1; 
            --border: #333; 
            --app-height: 100vh;
            --safe-top: env(safe-area-inset-top, 0px);
            --safe-bottom: env(safe-area-inset-bottom, 0px);
            --safe-left: env(safe-area-inset-left, 0px);
            --safe-right: env(safe-area-inset-right, 0px);
        }
        @supports (height: 100dvh) {
            :root { --app-height: 100dvh; }
        }
        * { box-sizing: border-box; outline: none; user-select: none; -webkit-tap-highlight-color: transparent; }
        
        body, html { 
            margin: 0; 
            padding: 0;
            width: 100%; 
            /* ä½¿ç”¨ dvh (Dynamic Viewport Height)ï¼Œè‡ªå‹•éš¨ç¶²å€åˆ—ä¼¸ç¸®ï¼Œä½†ä¸è§¸ç™¼æ»¾å‹• */
            height: 100dvh; 
            overflow: hidden; 
            position: fixed; /* é˜²æ­¢æ©¡çš®ç­‹å›å½ˆ */
            background: #000;
            overscroll-behavior: none;
        }
        
        #app { 
            display: flex; 
            position: fixed;
            top: 0;
            bottom: 0;
            left: 0;
            right: 0;
            /* æ”¯æ´èˆŠç‰ˆç€è¦½å™¨çš„å‚™æ¡ˆï¼Œå†ç”± 100dvh è¦†è“‹ */
            height: 100vh;
            height: 100dvh; 
            width: 100vw;
            overflow: hidden; 
            background: #000;
            
            /* è™•ç†æ‰‹æ©Ÿç€æµ·èˆ‡åº•éƒ¨å°ç™½æ¢ (Safe Area) */
            padding-top: env(safe-area-inset-top, 0px);
            padding-right: env(safe-area-inset-right, 0px);
            padding-bottom: env(safe-area-inset-bottom, 0px);
            padding-left: env(safe-area-inset-left, 0px);
        }

        /* ç¢ºä¿å…§å®¹å€åŸŸå¡«æ»¿å‰©é¤˜ç©ºé–“ï¼Œä¸è¢«æ¨æ“  */
        .canvas-area { 
            flex: 1; 
            height: 100%; 
            width: 100%;
            position: relative;
            touch-action: none; /* ç¦æ­¢ç€è¦½å™¨é è¨­ç¸®æ”¾èˆ‡å¹³ç§» */
        }
        html {
            position: fixed;
            width: 100vw;
            height: var(--app-height);
        }
        body {
            width: 100vw;
            height: var(--app-height);
        }
        
        /* å´é‚Šæ¬„ï¼šåŠ å…¥å¹³æ»‘ä½ç§» */
        .sidebar { 
            width: 340px; min-width: 340px; background: var(--panel-bg); border-right: 1px solid var(--border); 
            display: flex; flex-direction: column; height: 100%; 
            z-index: 1500; transition: transform 0.3s ease, margin-left 0.3s ease;
            position: relative;
            padding-top: max(0px, env(safe-area-inset-top)); /* é©æ‡‰ notch */
        }
        /* æ”¶é—”æ™‚ï¼šä½¿ç”¨ margin-left è² å€¼è®“ç•«å¸ƒè·Ÿè‘—è¢«ã€Œæ‹‰ã€éå» */
        .sidebar.collapsed { margin-left: -340px; } 

        /* ä¿®æ­£å¾Œçš„æ£‹ç›¤æ ¼èƒŒæ™¯èˆ‡ä½ˆå±€ */
        .canvas-area { 
            flex: 1; position: relative; background: #050505; 
            display: flex; justify-content: center; align-items: center; overflow: hidden; 
            background-image: 
                linear-gradient(45deg, #151515 25%, transparent 25%), 
                linear-gradient(-45deg, #151515 25%, transparent 25%), 
                linear-gradient(45deg, transparent 75%, #151515 75%), 
                linear-gradient(-45deg, transparent 75%, #151515 75%);
            background-size: 20px 20px;
            background-position: 0 0, 0 10px, 10px -10px, -10px 0px;
        }
        /* --- 1. å·¦ä¸Šè§’é–‹å•Ÿä¸‰è§’å½¢ (å·¦å³ç›¸å) --- */
        .sidebar-open-triangle {
            position: fixed; top: var(--safe-top); left: var(--safe-left);
            width: 65px; height: 65px; /* å¢åŠ æ„Ÿæ‡‰ç¯„åœåˆ° 65px */
            background: transparent; /* èƒŒæ™¯é€æ˜ï¼Œåƒ…ä½œç‚ºæ„Ÿæ‡‰å™¨ */
            cursor: pointer; z-index: 2500;
            display: flex; justify-content: flex-start; align-items: flex-start;
            transition: brightness 0.2s;
            pointer-events: auto; /* ç¢ºä¿åœ¨ç•«å¸ƒä¸Šæ–¹å¯è¢«é»æ“Š */
        }
        /* è¦–è¦ºä¸Šçš„é»ƒè‰²ä¸‰è§’å½¢ */
        .sidebar-open-triangle::before {
            content: '';
            position: absolute; top: 0; left: 0;
            width: 40px; height: 40px; /* ç¶­æŒåŸæœ¬ 40px è¦–è¦ºå¤–è§€ */
            background: var(--accent);
            clip-path: polygon(0 0, 100% 0, 0 100%);
            z-index: -1;
        }
        /* ç®­é ­ç¬¦è™Ÿ */
        .sidebar-open-triangle::after {
            content: 'â¯'; font-size: 12px; color: #000; font-weight: bold;
            margin-top: 5px; margin-left: 8px;
        }
        .sidebar-open-triangle:hover::before { filter: brightness(1.2); }

        /* --- 2. å´é‚Šå·¥å…·æŠ½å±œ: åº•éƒ¨é«˜åº¦é©æ‡‰èˆ‡å³å´ç§»ä½æ”¯æ´ --- */
        .floating-drawer-top-right {
            position: fixed; 
            right: calc(15px + var(--safe-right)); 
            top: calc(15px + var(--safe-top)); 
            display: flex; flex-direction: column; gap: 6px;
            z-index: 2000;
            pointer-events: auto;
            transition: all 0.3s ease;
        }

        /* é¸å–®çµ±ä¸€å‘å·¦æ–¹å½ˆå‡º */
        .floating-drawer-top-right .drawer-content {
            position: absolute;
            left: auto;
            right: 52px;
            top: 0;
            transform-origin: right center;
            animation: drawerInLeft 0.2s ease-out;
            background: rgba(28, 28, 28, 0.98);
            border: 1px solid #444;
            border-radius: 10px;
            padding: 15px;
            width: 240px; 
            backdrop-filter: blur(15px);
            box-shadow: -10px 0 30px rgba(0,0,0,0.8);
            z-index: 2100;
        }

        /* --- æµ®å‹•æŠ½å±œé¸å–® --- */
        .floating-drawer-top {
            position: fixed; 
            left: calc(15px + var(--safe-left)); 
            top: calc(15px + var(--safe-top));
            display: flex; flex-direction: column; gap: 6px;
            z-index: 2000;
        }

        .drawer-group { position: relative; display: flex; align-items: center; }

        /* å³å´é¸å–®å½ˆå‡ºå‹•ç•« */
        @keyframes drawerIn { from { opacity: 0; transform: scale(0.9) translateX(-10px); } to { opacity: 1; transform: scale(1) translateX(0); } }
        /* å·¦å´é¸å–®å½ˆå‡ºå‹•ç•« (ç”¨æ–¼å³å´å·¥å…·) */
        @keyframes drawerInLeft { from { opacity: 0; transform: scale(0.9) translateX(10px); } to { opacity: 1; transform: scale(1) translateX(0); } }

        /* æ–¹å½¢åœ“è§’ä¸»æŒ‰éˆ• (42px ç·Šæ¹Šå°ºå¯¸) */
        .drawer-main-btn {
            width: 42px; height: 42px;
            background: rgba(20, 20, 20, 0.95);
            border: 1px solid var(--accent);
            border-radius: 8px; 
            color: var(--accent);
            cursor: pointer;
            display: flex; align-items: center; justify-content: center;
            font-size: 18px; backdrop-filter: blur(10px);
            box-shadow: 0 4px 15px rgba(0,0,0,0.5);
            transition: all 0.2s;
            flex-shrink: 0;
            z-index: 2101;
        }
        .drawer-main-btn:hover { background: var(--accent); color: #000; }
        .drawer-main-btn.active { background: #fff; color: #000; border-color: #fff; transform: scale(1.05); }
        .drawer-main-btn:disabled { opacity: 0.3; cursor: not-allowed; }

        /* å½ˆå‡ºé¢æ¿:å¯¬åº¦å„ªåŒ–è‡³ 240px,å¾¹åº•è§£æ±ºæ‹‰æ¡¿èˆ‡æ²è»¸å•é¡Œ */
        .drawer-content {
            position: absolute; left: 52px;
            display: flex; flex-direction: column;
            background: rgba(28, 28, 28, 0.98);
            border: 1px solid #444;
            border-radius: 10px;
            padding: 15px;
            width: 240px; 
            backdrop-filter: blur(15px);
            box-shadow: 10px 0 30px rgba(0,0,0,0.8);
            transform-origin: left center;
            animation: drawerIn 0.2s ease-out;
            z-index: 2100;
            overflow-x: hidden;
        }
        .floating-drawer-top .drawer-content { top: 0; }
        .floating-drawer-bottom .drawer-content { bottom: 0; }

        @keyframes drawerIn { from { opacity: 0; transform: scale(0.9) translateX(-10px); } to { opacity: 1; transform: scale(1) translateX(0); } }

        /* å…§å®¹å…ƒä»¶æ¨£å¼çµ±ä¸€åŒ– */
        .drawer-content label { color: var(--accent); margin: 10px 0 5px 0; font-size: 12px; display: block; font-weight: bold; }
        .drawer-content input[type=range] { 
            width: 100% !important; 
            height: 30px; 
            cursor: pointer; 
            touch-action: pan-x !important; 
            user-select: auto !important;
            -webkit-appearance: slider-horizontal;
            background: transparent;
        }
        .drawer-content input[type=number], .drawer-content textarea, .drawer-content select { 
            width: 100%; background: #1a1a1a; border: 1px solid #444; color: white; font-size: 12px; padding: 6px; border-radius: 4px;
        }
        .drawer-content .row.compact { display: flex; gap: 5px; align-items: center; margin-bottom: 5px; }
        .drawer-content button { 
            width: 100%; background: var(--accent); color: #000; border: none; padding: 8px; border-radius: 4px; 
            cursor: pointer; font-weight: bold; font-size: 12px; margin-top: 5px;
        }
        .drawer-content button.secondary { background: #444; color: white; }
        .drawer-content button.danger { background: #522; color: #f55; border: 1px solid #f55; }
        .drawer-content .val-display { font-size: 11px; color: var(--accent); min-width: 30px; text-align: right; }

        .drawer-content input[type=checkbox] {
            width: 18px !important;
            height: 18px !important;
            margin-right: 8px;
            cursor: pointer;
            accent-color: var(--accent);
            /* ç¢ºä¿è§¸æ§ä¸æœƒç©¿é€ */
            pointer-events: auto !important; 
        }

        .drawer-content input, 
        .drawer-content textarea, 
        .drawer-content select {
            user-select: auto !important;       /* å…è¨±é¸å–æ–‡å­— */
            -webkit-user-select: auto !important;
            pointer-events: auto !important;    /* ç¢ºä¿å¯é»æ“Š */
            touch-action: manipulation !important; /* å„ªåŒ–è§¸æ§éŸ¿æ‡‰ */
        }
        
        .drawer-content input[type=checkbox] {
            width: 22px !important;  /* åŠ å¤§è§¸æ§ç¯„åœ */
            height: 22px !important;
            cursor: pointer;
        }

        .drawer-content input[type=color] {
            width: 100%;
            height: 40px;
            cursor: pointer;
        }


        /* å³ä¸Šè§’ 45åº¦é»ƒè‰²ä¸‰è§’å½¢æ”¶é—”éˆ• (åŠ å¤§åˆ¤å®šç¯„åœç‰ˆ) */
        .sidebar-close-triangle {
            position: absolute; top: 0; right: 0;
            width: 65px; height: 65px; /* å¢åŠ æ„Ÿæ‡‰ç¯„åœåˆ° 65px */
            background: transparent;
            cursor: pointer; z-index: 1600;
            display: flex; justify-content: flex-end; align-items: flex-start;
            transition: brightness 0.2s;
        }
        /* è¦–è¦ºä¸Šçš„é»ƒè‰²ä¸‰è§’å½¢ */
        .sidebar-close-triangle::before {
            content: '';
            position: absolute; top: 0; right: 0;
            width: 40px; height: 40px; /* ç¶­æŒåŸæœ¬ 40px è¦–è¦ºå¤–è§€ */
            background: var(--accent);
            clip-path: polygon(0 0, 100% 0, 100% 100%);
            z-index: -1;
        }
        /* ç®­é ­ç¬¦è™Ÿ */
        .sidebar-close-triangle::after {
            content: 'â®'; font-size: 12px; color: #000; font-weight: bold;
            margin-top: 5px; margin-right: 8px;
        }
        .sidebar-close-triangle:hover::before { filter: brightness(1.2); }



        .canvas-area:active { cursor: grabbing; }

        .canvas-wrapper {
            position: relative;
            box-shadow: 0 0 30px rgba(0,0,0,0.8);
            transform-origin: center;
        }

        canvas { 
            display: block;
            max-width: none; max-height: none; 
            pointer-events: none;
            z-index: 10; 
        }

        .overlay-layer {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            pointer-events: none; 
            z-index: 20; 
        }

        .node-marker {
            position: absolute;
            /* ç§»é™¤å›ºå®šçš„ width/heightï¼Œæ”¹ç”± Vue å‹•æ…‹ç¶å®š */
            border-radius: 50%;
            border: 1px solid #000;
            transform: translate(-50%, -50%);
            box-shadow: 0 0 2px rgba(0,0,0,0.5);
            pointer-events: none; /* è®“é»æ“Šç©¿é€åˆ°ç•«å¸ƒè™•ç†å‡½æ•¸ */
        }

        /* æ—‹è½‰æ‰‹æŸ„ */
        .rotate-handle {
            position: absolute;
            border-radius: 50%;
            background: #FFD700;
            border: 2px solid #000;
            transform: translate(-50%, -50%);
            display: flex; 
            justify-content: center; 
            align-items: center;
            color: black; 
            font-weight: bold;
            box-shadow: 0 0 5px rgba(0,0,0,0.8);
            cursor: pointer;
            pointer-events: auto;
            z-index: 2100;
        }
        .rotate-handle:hover {
            background: #fff;
        }

        .selection-box {
            position: absolute;
            border: 1px dashed #00e5ff;
            background-color: rgba(0, 229, 255, 0.15);
            pointer-events: none;
        }
        
        .zoom-ctrl {
            position: absolute; 
            bottom: calc(40px + var(--safe-bottom)) !important;
            right: calc(20px + var(--safe-right)) !important;
            left: auto !important;
            background: rgba(0,0,0,0.8); padding: 10px; border-radius: 8px;
            display: flex; align-items: center; gap: 10px; border: 1px solid #444; 
            z-index: 2000; 
            box-shadow: 0 5px 15px rgba(0,0,0,0.5);
            backdrop-filter: blur(4px);
            touch-action: none;
            /* ä¿®æ­£ï¼šåŠ å…¥è®Šå½¢åŸºæº–é»èˆ‡éæ¸¡å‹•ç•« */
            transform-origin: right bottom;
            transition: transform 0.3s ease, opacity 0.3s ease;
        }
        /* ç•¶å´é‚Šæ¬„æ”¶é—”æ™‚ï¼Œç¸®å°ç‚º 0.6 å€ (0.5å€åœ¨æ‰‹æ©Ÿä¸Šå¤ªå°ï¼Œå»ºè­° 0.6 è¼ƒå¹³è¡¡) */
        .zoom-ctrl.minimized {
            transform: scale(0.6);
            opacity: 0.8;
        }
        .zoom-ctrl.minimized:hover, .zoom-ctrl.minimized:active {
            transform: scale(1); /* è§¸ç¢°æˆ–æ»‘é¼ ç§»å…¥æ™‚è‡ªå‹•å¾©åŸå¤§å°æ–¹ä¾¿æ“ä½œ */
            opacity: 1;
        }
        .zoom-ctrl input { 
            width: 100px; 
            height: 30px; /* åŠ é«˜è§¸æ§ç¯„åœ */
            accent-color: var(--accent); 
            touch-action: pan-x !important; /* å…è¨±æ°´å¹³æ‹–æ›³ */
            cursor: pointer;
        }

        .author-link {
            position: absolute;
            bottom: 12px;
            right: 25px;
            z-index: 1000;
            font-size: 11px;
            font-family: 'Montserrat', sans-serif;
            color: white;
            text-decoration: none;
            opacity: 0.4;
            transition: opacity 0.3s, transform 0.3s;
            letter-spacing: 0.5px;
            background: rgba(0,0,0,0.4);
            padding: 5px 10px;
            border-radius: 4px;
            backdrop-filter: blur(2px);
        }

        .author-link:hover {
            opacity: 1;
            color: var(--accent);
            transform: translateY(-2px);
        }
        
        .float-input { 
            position: absolute; 
            background: transparent; /* é€æ˜èƒŒæ™¯ï¼Œç„¡ç¸«ç·¨è¼¯ */
            color: white; 
            border: 1px dashed rgba(255, 255, 255, 0.5); /* ç·¨è¼¯æ™‚é¡¯ç¤ºæ·¡æ·¡çš„è™›ç·šæ¡† */
            margin: 0; 
            padding: 0;
            overflow: hidden; 
            resize: none; 
            z-index: 3000; 
            text-align: center; 
            outline: none; 
            transform-origin: center center; 
            border-radius: 0;
            line-height: 1.2 !important; 
            white-space: pre; 
            pointer-events: auto;
            box-shadow: none;
            /* æ ¸å¿ƒä¿®æ­£ï¼šå…è¨±æ–‡å­—é¸å–èˆ‡æ¸¸æ¨™æ“ä½œ */
            user-select: text !important;
            -webkit-user-select: text !important;
        }
        
        .sidebar-scroll { flex: 1; overflow-y: auto; padding: 20px; }

        .sidebar-fixed {
            flex: 0 0 auto; 
            background: #1e1e1e; 
            border-top: 2px solid #333; 
            padding: 15px 20px;
            box-shadow: 0 -5px 20px rgba(0,0,0,0.5);
            z-index: 10;
            transition: all 0.3s ease;
        }

        .sidebar-header a:hover {
            opacity: 1 !important;
            text-decoration: underline !important;
        }
        h1, h2 { color: var(--accent); margin: 0; font-size: 18px; font-weight: bold; }
        
        .sidebar-fixed h2 { 
            margin-top: 0; font-size: 14px; color: #aaa; border:none; padding-bottom: 0; margin-bottom: 0; 
            cursor: pointer; display: flex; justify-content: space-between; align-items: center;
        }
        .sidebar-fixed h2:hover { color: var(--accent); }
        
        .settings-content {
            overflow: hidden;
            transition: max-height 0.3s ease, opacity 0.3s ease;
        }

        .lang-switch {
            font-size: 12px; background: #333; color: #ccc; padding: 4px 8px; border-radius: 4px; cursor: pointer; border: 1px solid #555;
        }
        .lang-switch:hover { background: #444; color: white; }

        .control-group { background: rgba(255,255,255,0.03); padding: 10px; border-radius: 6px; margin-bottom: 10px; }
        .row { display: flex; gap: 8px; align-items: center; margin-bottom: 8px; }
        .col { flex: 1; }
        
        .row.compact { gap: 4px; }
        .row.compact .col { min-width: 0; }
        .row.compact input { padding: 4px 2px; text-align: center; font-size: 11px; }
        .row.compact label { font-size: 10px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }

        .val-display { font-size: 12px; color: var(--accent); min-width: 35px; text-align: right; font-family: monospace; }

        label { display: block; font-size: 12px; color: #aaa; margin-bottom: 4px; }
        
        input[type=number], input[type=text], select { 
            width: 100%; background: #2a2a2a; border: 1px solid #444; color: white; padding: 5px; border-radius: 4px; 
            transition: border-color 0.2s;
        }
        input[type=number]:focus, input[type=text]:focus { border-color: var(--accent); }
        
        input[type=range] { width: 100%; accent-color: var(--accent); cursor: pointer; flex: 1; }
        input[type=checkbox] { transform: scale(1.2); accent-color: var(--accent); }
        input[type=color] { width: 100%; height: 35px; padding: 0; border: none; cursor: pointer; background: none; }
        textarea { width: 100%; background: #2a2a2a; border: 1px solid #444; color: white; padding: 8px; border-radius: 4px; resize: vertical; min-height: 60px; margin-bottom: 10px; font-family: inherit; }
        
        button { width: 100%; background: var(--accent); color: #000; border: none; padding: 8px; border-radius: 4px; cursor: pointer; font-weight: bold; margin-bottom: 5px; }
        button:hover { filter: brightness(1.1); }
        button:disabled { opacity: 0.5; cursor: not-allowed; filter: grayscale(1); }
        button.secondary { background: #444; color: white; }
        button.danger { background: #522; color: #f55; border: 1px solid #f55; }
        button.small-btn { width: auto; padding: 5px 10px; font-size: 12px; }
        button.btn-active { background: #00e5ff; color: #000; box-shadow: 0 0 10px rgba(0, 229, 255, 0.5); }
        
        .disabled-block { opacity: 0.4; pointer-events: none; transition: 0.3s; }

        .mode-switch { display: flex; background: #222; padding: 3px; border-radius: 6px; margin-bottom: 15px; }
        .mode-btn { 
            flex: 1; 
            display: flex; 
            flex-direction: column; 
            align-items: center; 
            justify-content: center; 
            padding: 6px 2px; 
            cursor: pointer; 
            color: #666; 
            font-size: 11px; 
            border-radius: 4px; 
            transition: 0.2s; 
            line-height: 1.2;
        }
        .mode-btn .mode-icon { font-size: 18px; margin-bottom: 2px; display: block; }
        .mode-btn.active { background: var(--accent); color: #000; font-weight: bold; }
        
        .selected-panel { border: 1px solid var(--accent); background: rgba(255, 215, 0, 0.05); }
        .bg-tabs { display: flex; gap: 5px; margin-bottom: 10px; }
        .bg-tab { flex: 1; background: #333; color: #888; font-size: 12px; text-align: center; padding: 5px; cursor: pointer; border-radius: 4px; }
        .bg-tab.active { background: #555; color: white; border: 1px solid #777; }

        .modal-overlay { 
            position: fixed; top: 0; left: 0; width: 100%; height: 100%; 
            background: rgba(0,0,0,0.8); z-index: 9999; 
            display: flex; justify-content: center; align-items: center; 
            backdrop-filter: blur(2px); 
        }
        .modal-box { 
            background: var(--panel-bg); border: 1px solid var(--accent); 
            width: 320px; padding: 20px; border-radius: 8px; 
            text-align: center; box-shadow: 0 10px 30px rgba(0,0,0,0.5); 
        }
        .modal-box h3 { color: var(--accent); margin-top: 0; font-size: 20px; margin-bottom: 10px; }
        .modal-box p { color: #ccc; margin: 10px 0 25px 0; font-size: 14px; line-height: 1.5; white-space: pre-line; }
        .modal-btn-row { display: flex; gap: 10px; }
        
        .info-grid {
            display: grid; grid-template-columns: auto 1fr; gap: 5px 10px;
            font-size: 12px; color: #ccc; margin-top: 5px;
        }
        .info-label { color: #888; white-space: nowrap; }
        .info-val { text-align: right; font-family: monospace; color: #ddd; word-break: break-all; }
        .info-header { grid-column: 1 / -1; color: var(--accent); font-weight: bold; margin-bottom: 5px; border-bottom: 1px solid #444; padding-bottom: 2px;}
        .info-missing { color: #f55; font-weight: bold; }

        .canvas-area.connecting { cursor: crosshair !important; }
        .canvas-area.connecting .node-marker { pointer-events: none; opacity: 0.5; }
        
        /* --- å°äººè²¼ç´™å°ˆå±¬æ¨£å¼ (åš´æ ¼åº•éƒ¨åŸºæº–) --- */
        .btn-sticker-wrapper {
            position: relative;
            margin-top: 10px;
            overflow: visible !important; 
        }
        .pixel-sticker {
            position: absolute;
            right: 165px;
            /* é–å®šåœ¨æŒ‰éˆ•ä¸Šæ–¹ï¼Œå¾®èª¿ 2px å£“åœ¨é‚Šæ¡†ä¸Š */
            bottom: calc(100% - 34px); 
            
            /* å®¹å™¨è¨­å®šç‚ºæœ€å¤§é«˜åº¦ï¼Œä½†ä¸é™åˆ¶å…§å®¹å¦‚ä½•ç”Ÿé•· */
            width: 37px;
            height: 55px; 
            
            z-index: 999;
            pointer-events: none;
            image-rendering: pixelated;
            
            /* ç¢ºä¿ä»»ä½•è®Šå½¢éƒ½ä»¥è…³åº•ç‚ºä¸­å¿ƒ */
            transform-origin: bottom center; 
        }
        .pixel-sticker svg {
            width: 37px;
            height: auto; /* è®“é«˜åº¦æ ¹æ“š viewBox è‡ªå‹•æ±ºå®š (49px æˆ– 55px) */
            display: block;
            shape-rendering: crispEdges;
            position: absolute;
            bottom: 0;    /* é—œéµï¼šSVG çš„è…³åº•è²¼é½Šå®¹å™¨åº•éƒ¨ */
        }
        .pixel-sticker .frame-group {
            opacity: 0;
            position: absolute;
            bottom: 0;    /* é—œéµï¼šå½±æ ¼ç¾¤çµ„è²¼é½Šåº•éƒ¨ */
            left: 0;
            width: 100%;
            height: 100%; /* é›–ç„¶è¨­ç‚º 100%ï¼Œä½†å…§éƒ¨çš„ SVG æœƒé åº• */
        }

        /* ç‹€æ…‹é¡¯ç¤ºæ§åˆ¶ */
        .pixel-sticker.state-hover { display: none; }
        .pixel-sticker.state-idle { display: block; }
        .btn-sticker-wrapper:hover .pixel-sticker.state-idle { display: none; }
        .btn-sticker-wrapper:hover .pixel-sticker.state-hover { display: block; }

        /* 4 å½±æ ¼å¾ªç’°å‹•ç•« (é€Ÿåº¦å¯æ”¹ 2.0s) */
        .pixel-sticker.playing .f1 { animation: pixel-anim-f1 2.2s steps(1) infinite; }
        .pixel-sticker.playing .f2 { animation: pixel-anim-f2 2.2s steps(1) infinite; }
        .pixel-sticker.playing .f3 { animation: pixel-anim-f3 2.2s steps(1) infinite; }
        .pixel-sticker.playing .f4 { animation: pixel-anim-f4 2.2s steps(1) infinite; }

        @keyframes pixel-anim-f1 { 0%, 25% { opacity: 1; } 25.01%, 100% { opacity: 0; } }
        @keyframes pixel-anim-f2 { 0%, 25% { opacity: 0; } 25.01%, 50% { opacity: 1; } 50.01%, 100% { opacity: 0; } }
        @keyframes pixel-anim-f3 { 0%, 50% { opacity: 0; } 50.01%, 75% { opacity: 1; } 75.01%, 100% { opacity: 0; } }
        @keyframes pixel-anim-f4 { 0%, 75% { opacity: 0; } 75.01%, 100% { opacity: 1; } }

        /* æ»‘é¼ ç§»å…¥æ™‚çš„å¾®å‹•ï¼ŒåŒæ¨£ä»¥è…³åº•ç‚ºæº– */
        .btn-sticker-wrapper:hover .pixel-sticker {
            transform: translateY(-2px); 
        }
    </style>
</head>
<body @contextmenu="handleGlobalContextMenu">

<div id="app">
    <!-- A. å…¨åŸŸç¢ºèªè¦–çª— (Modal) -->
    <div v-if="showConfirm" class="modal-overlay">
        <div class="modal-box">
            <h3>{{ confirmTitle }}</h3>
            <p>{{ confirmMsg }}</p>
            <div class="modal-btn-row">
                <button @click="executeConfirm">{{ ui.confirm }}</button>
                <button class="secondary" @click="showConfirm=false" v-if="!isAlert">{{ ui.cancel }}</button>
            </div>
        </div>
    </div>

    <!-- B. å´é‚Šæ¬„ (Sidebar) -->
    <div class="sidebar" :class="{ 'collapsed': isSidebarCollapsed }">
    <!-- æ–°å¢ä¸‰è§’å½¢æ”¶é—”éˆ• -->
    <div class="sidebar-close-triangle" @click.stop="toggleSidebar" title="æ”¶åˆé¸å–®"></div>
    
    <div class="sidebar-scroll">
        <!-- æ¨™é¡Œå€åŸŸä¿æŒåŸæ¨£ï¼Œä¸éœ€è¦é¡å¤–çš„æ”¶é—”æŒ‰éˆ•äº† -->
        <div class="sidebar-header" style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px; padding-right: 35px;">
            <h1 style="font-family: 'Montserrat', sans-serif; letter-spacing: -0.5px; font-size: 18px; margin: 0;">{{ ui.appTitle }}</h1>
            <button class="lang-switch" @click="toggleLang" style="width:auto; margin:0; padding:4px 8px;">{{ lang === 'zh' ? 'EN' : 'ä¸­æ–‡' }}</button>
        </div>
            
            <div class="mode-switch">
                <div class="mode-btn" :class="{active: mode==='layout'}" @click="setMode('layout')"><span class="mode-icon">ğŸ“</span><span>{{ ui.modeLayout }}</span></div>
                <div class="mode-btn" :class="{active: mode==='image'}" @click="setMode('image')"><span class="mode-icon">ğŸ–¼ï¸</span><span>{{ ui.modeImage }}</span></div>
                <div class="mode-btn" :class="{active: mode==='text'}" @click="setMode('text')"><span class="mode-icon">ğŸ“</span><span>{{ ui.modeText }}</span></div>
                <div class="mode-btn" :class="{active: mode==='template'}" @click="setMode('template')"><span class="mode-icon">ğŸ§©</span><span>{{ ui.modeTemplate }}</span></div>
                <div class="mode-btn" :class="{active: mode==='settings'}" @click="setMode('settings')"><span class="mode-icon">âš™ï¸</span><span>{{ ui.globalSettings }}</span></div>
            </div>

            <!-- 1. æ¨¡æ¿æ¨¡å¼ (ä¿ç•™åŸå§‹æ‰€æœ‰åƒæ•¸) -->
            <div v-if="mode === 'template'">
                <div class="control-group">
                    <label style="color:var(--accent)">{{ ui.tplSettings }}</label>
                    <label>ä¸­å¿ƒåº§æ¨™ (Center X / Y)</label>
                    <div class="row compact">
                        <div class="col"><input type="number" v-model.number="tplCenterX" @input="updateTemplate" placeholder="X"></div>
                        <div class="col"><input type="number" v-model.number="tplCenterY" @input="updateTemplate" placeholder="Y"></div>
                        <button class="secondary small-btn" style="width:auto; padding:5px 10px;" @click="resetTplCenter" title="é‡ç½®åˆ°ç•«å¸ƒä¸­å¿ƒ">ğŸ¯</button>
                    </div>
                    <label style="color:#FFD700">{{ ui.nodeCount || 'åœ–ç‰‡æ•¸é‡' }} ({{ tplCount }})</label>
                    <input type="range" v-model.number="tplCount" min="1" max="50" step="1" @input="updateTemplate">
                    <label>{{ ui.tplSpacing }} ({{ tplPadding }})</label>
                    <input type="range" v-model.number="tplPadding" min="50" max="500" @input="updateTemplate">
                    <label style="color:#00ffaa;">åœ–ç‰‡å¼·åº¦ (Strength) ({{ tplStrength }})</label>
                    <input type="range" v-model.number="tplStrength" min="1" max="10" step="1" @input="updateTemplate">
                    <label>{{ ui.tplRoundness }} ({{ tplSpacing }})</label>
                    <input type="range" v-model.number="tplSpacing" min="1" max="20" @input="updateTemplate">
                    <label>{{ ui.tplJitter }} ({{ tplJitter }})</label>
                    <input type="range" v-model.number="tplJitter" min="0" max="20" @input="updateTemplate">
                </div>
                <div class="control-group">
                    <label style="color:var(--accent)">{{ ui.tplSelect }}</label>
                    <div class="row compact">
                        <button class="col secondary small-btn" @click="applyPreset('flower')">ğŸ• {{ ui.tplFlower }}</button>
                        <button class="col secondary small-btn" @click="applyPreset('radial')">â˜€ {{ ui.tplRadial }}</button>
                        <button class="col secondary small-btn" @click="applyPreset('grid')">â–¦ {{ ui.tplGrid }}</button>
                    </div>
                    <div class="row compact">
                        <button class="col secondary small-btn" @click="applyPreset('circle')">ğŸ¥ {{ ui.tplCircle }}</button>
                        <button class="col secondary small-btn" @click="applyPreset('honeycomb')">âœ¿ {{ ui.tplHoneycomb }}</button>
                        <button class="col secondary small-btn" @click="applyPreset('masonry')">ğŸ’¥ {{ ui.tplMasonry }}</button>
                    </div>
                </div>
            </div>

            <!-- 2. æ–‡å­—æ¨¡å¼ (å«æ–‡å­—ã€è²¼åœ–èˆ‡æ–°ç¿»è½‰åŠŸèƒ½) -->
            <div v-if="mode === 'text'">
                <div class="row">
                    <button class="col" @click="addText">â• {{ ui.addText }}</button>
                    <button class="col" @click="$refs.stickerInput.click()">ğŸ–¼ï¸ è²¼åœ–</button>
                    <input type="file" ref="stickerInput" accept="image/*" style="display:none" @change="handleAddSticker">
                    <button class="col secondary" @click="duplicateText">ğŸ“‘ {{ ui.copyText }}</button>
                </div>
                <input type="file" ref="fontInput" accept=".ttf,.otf,.woff,.woff2" style="display:none" @change="handleFontUpload">

                <!-- A. æ–‡å­—æ§åˆ¶é¢æ¿ -->
                <div v-if="selectedTextId" class="control-group selected-panel">
                    <label style="color:var(--accent)">{{ ui.editContent }} <span v-if="selectedTextIds.length>1" style="font-size:10px;color:#888"> ({{selectedTextIds.length}})</span></label>
                    <textarea :value="getSelectedText().content" @input="e => updateTextModeTransform('content', e.target.value)"></textarea>

                    <div class="row compact">
                        <div class="col"><label>X</label><input type="number" :value="getSelectedText().x" @input="e => updateTextModeTransform('x', e.target.value)" step="1"></div>
                        <div class="col"><label>Y</label><input type="number" :value="getSelectedText().y" @input="e => updateTextModeTransform('y', e.target.value)" step="1"></div>
                    </div>

                    <div class="row compact" style="margin-top:8px;">
                        <div class="col"><label>{{ ui.size }}</label><input type="number" :value="getSelectedText().fontSize" @input="e => updateTextModeTransform('fontSize', e.target.value)" min="1"></div>
                        <div class="col"><label>{{ ui.rotate }}</label><input type="number" :value="getSelectedText().rotation" @input="e => updateTextModeTransform('rotation', e.target.value)"></div>
                        <div class="col"><label>{{ ui.skewX }}</label><input type="number" :value="getSelectedText().skewX" @input="e => updateTextModeTransform('skewX', e.target.value)"></div>
                        <div class="col"><label>{{ ui.skewY }}</label><input type="number" :value="getSelectedText().skewY" @input="e => updateTextModeTransform('skewY', e.target.value)"></div>
                    </div>
                    
                    <label>åœ–å±¤æ¨¡å¼ ({{ getZIndexLabel(getSelectedText().zIndex) }})</label>
                    <div class="row" style="gap: 5px;">
                        <input type="number" :value="getSelectedText().zIndex < gridZIndex ? getSelectedText().zIndex : getSelectedText().zIndex - gridZIndex" @input="e => updateTextModeTransform('zIndex', e.target.value)" style="flex: 1;" placeholder="å±¤æ•¸">
                        <button :class="isAllSelectedInBackground() ? 'btn-active' : 'secondary'" @click="toggleBackgroundMode" style="width: auto; padding: 5px 10px; margin: 0; white-space: nowrap; font-size: 12px;">
                            {{ isAllSelectedInBackground() ? 'ğŸ–¼ï¸ èƒŒæ™¯ä¸­' : 'ğŸ“ è¨­ç‚ºèƒŒæ™¯' }}
                        </button>
                    </div>
                    <div class="row" style="margin-top: 5px;">
                        <button class="secondary col small-btn" @click="moveLayer('top')">{{ ui.layerTop }}</button>
                        <button class="secondary col small-btn" @click="moveLayer('up')">{{ ui.layerUp }}</button>
                        <button class="secondary col small-btn" @click="moveLayer('down')">{{ ui.layerDown }}</button>
                        <button class="secondary col small-btn" @click="moveLayer('bottom')">{{ ui.layerBottom }}</button>
                    </div>
                    
                    <div style="margin-top: 10px; border-top: 1px solid #444; padding-top: 10px;">
                        <label>{{ ui.fontFamily }}</label>
                        <div class="row">
                            <select :value="getSelectedText().fontFamily" @input="e => updateTextModeTransform('fontFamily', e.target.value)" style="flex: 1;">
                                <option v-for="font in fontOptions" :key="font.value" :value="font.value" :style="{ fontFamily: font.value, fontSize: '16px' }">{{ font.label }}</option>
                            </select>
                            <button class="secondary small-btn" @click="$refs.fontInput.click()" style="width:auto; margin:0; padding: 5px 10px;" title="åŒ¯å…¥è‡ªå®šç¾©å­—å‹">ğŸ“</button>
                        </div>
                        <div class="row" style="margin-top:10px;">
                            <input type="color" :value="getSelectedText().color" style="flex: 2; height: 35px;" @input="e => updateTextModeTransform('color', e.target.value)">
                            <button class="secondary small-btn" :style="{background: getSelectedText().isBold ? '#666' : '#333'}" @click="toggleText('isBold')">B</button>
                            <button class="secondary small-btn" :style="{background: getSelectedText().isItalic ? '#666' : '#333'}" @click="toggleText('isItalic')">I</button>
                            <button class="secondary small-btn" :style="{background: getSelectedText().isUnderlined ? '#666' : '#333'}" @click="toggleText('isUnderlined')">U</button>
                            <button class="secondary small-btn" :style="{background: getSelectedText().isVertical ? '#666' : '#333'}" @click="toggleText('isVertical')">|||</button>
                        </div>
                        <label>{{ ui.textStroke }}</label>
                        <div class="row">
                            <input type="color" :value="getSelectedText().strokeColor" style="flex: 1; height: 35px;" @input="e => updateTextModeTransform('strokeColor', e.target.value)">
                            <input type="range" :value="getSelectedText().strokeWidth" @input="e => updateTextModeTransform('strokeWidth', e.target.value)" min="0" max="20" style="flex: 2">
                            <span class="val-display">{{getSelectedText().strokeWidth}}</span>
                        </div>
                    </div>
                    <button class="danger" style="margin-top:10px" @click="deleteText">ğŸ—‘ï¸ {{ ui.delText }}</button>
                </div>

                <!-- B. è²¼åœ–æ§åˆ¶é¢æ¿ (åŒ…å«æ–°å¢çš„ç¿»è½‰æŒ‰éˆ•) -->
                <div v-if="selectedStickerId" class="control-group selected-panel">
                    <label style="color:#00ffaa">è²¼åœ–è¨­å®š <span v-if="selectedStickerIds.length>1" style="font-size:10px;color:#888"> ({{selectedStickerIds.length}})</span></label>
                    <div class="row compact">
                        <div class="col"><label>X</label><input type="number" :value="getSelectedSticker().x" @input="e => updateTextModeTransform('x', e.target.value)"></div>
                        <div class="col"><label>Y</label><input type="number" :value="getSelectedSticker().y" @input="e => updateTextModeTransform('y', e.target.value)"></div>
                    </div>
                    <div class="row compact" style="margin-top:8px;">
                        <div class="col"><label>{{ ui.scale }}</label><input type="number" :value="getSelectedSticker().scale" min="0.1" step="0.1" @input="e => updateTextModeTransform('scale', e.target.value)"></div>
                        <div class="col"><label>{{ ui.rotate }}</label><input type="number" :value="getSelectedSticker().rotation" @input="e => updateTextModeTransform('rotation', e.target.value)"></div>
                    </div>
                    <label>é€æ˜åº¦ ({{ Math.round(getSelectedSticker().alpha * 100) }}%)</label>
                    <div class="row">
                        <input type="range" :value="getSelectedSticker().alpha * 100" min="0" max="100" @input="e => updateTextModeTransform('alpha', e.target.value / 100)" style="flex: 1;">
                        <span class="val-display">{{ Math.round(getSelectedSticker().alpha * 100) }}%</span>
                    </div>
                    <div class="row" style="margin-bottom: 8px;">
                        <button class="secondary col" @click="flipSticker">â†” {{ ui.flip }}</button>
                    </div>
                    <label>åœ–å±¤æ¨¡å¼ ({{ getZIndexLabel(getSelectedSticker().zIndex) }})</label>
                    <div class="row" style="gap: 5px;">
                        <input type="number" :value="getSelectedSticker().zIndex < gridZIndex ? getSelectedSticker().zIndex : getSelectedSticker().zIndex - gridZIndex" @input="e => updateTextModeTransform('zIndex', e.target.value)" style="flex: 1;" placeholder="å±¤æ•¸">
                        <button :class="isAllSelectedInBackground() ? 'btn-active' : 'secondary'" @click="toggleBackgroundMode" style="width: auto; padding: 5px 10px; margin: 0; white-space: nowrap; font-size: 12px;">
                            {{ isAllSelectedInBackground() ? 'ğŸ–¼ï¸ èƒŒæ™¯ä¸­' : 'ğŸ“ è¨­ç‚ºèƒŒæ™¯' }}
                        </button>
                    </div>
                    <div class="row" style="margin-top: 5px;">
                        <button class="secondary col small-btn" @click="moveLayer('top')">{{ ui.layerTop }}</button>
                        <button class="secondary col small-btn" @click="moveLayer('up')">{{ ui.layerUp }}</button>
                        <button class="secondary col small-btn" @click="moveLayer('down')">{{ ui.layerDown }}</button>
                        <button class="secondary col small-btn" @click="moveLayer('bottom')">{{ ui.layerBottom }}</button>
                    </div>
                    <button class="danger" style="margin-top:10px" @click="deleteSticker">ğŸ—‘ï¸ åˆªé™¤è²¼åœ–</button>
                </div>
            </div>

            <!-- 3. æ’ç‰ˆæ¨¡å¼ -->
            <div v-if="mode === 'layout'">
                <div class="row">
                    <button class="col" @click="addEmptyCell">ğŸ”² {{ ui.addEmpty }}</button>
                    <button class="col danger" :disabled="!selectedImgId" @click="deleteImg">ğŸ—‘ï¸ {{ ui.delCell }}</button>
                </div>
                <div v-if="selectedImgId" class="control-group selected-panel">
                    <label style="color:var(--accent)">{{ ui.nodeControl }}</label>
                    <label>{{ ui.nodeCount }}: {{ getSiteCount(selectedImgId) }}</label>
                    <div class="row">
                        <button class="col" @click="addPoint">â• {{ ui.addPoint }}</button>
                        <button class="secondary col" @click="removePoint">â– {{ ui.removePoint }}</button>
                    </div>
                    <div class="row">
                        <button class="col" :class="{'btn-active': isConnecting}" @click="toggleConnectMode">ğŸ”— {{ ui.connectNode }}</button>
                        <button class="secondary col" @click="resetToSingleNode">ğŸ’”åˆ†é›¢ç¯€é» {{ ui.resetSingle }}</button>
                    </div>
                    <div v-if="isConnecting" style="color:#00ffaa; font-size:11px; margin-bottom:5px; text-align:center;">{{ lang==='zh' ? 'ç¾åœ¨è«‹é»æ“Šç•«å¸ƒä»»æ„ä½ç½®ä»¥å»¶ä¼¸åœ–ç‰‡' : 'Click canvas to extend' }}</div>
                    <div v-if="selectedSiteIds.length > 0" style="margin-top: 10px; border-top: 1px solid #555; padding-top: 10px;">
                        <label style="color: #00ffaa;">{{ lang === 'zh' ? 'åº§æ¨™' : 'Coords (Linked)' }} <span style="font-size:10px; color:#888">({{ selectedSiteIds.length }})</span></label>
                        <div class="row">
                            <input type="number" :value="getPrimarySite().x" @input="e => updateMultiCoords('x', parseFloat(e.target.value))" step="0.01">
                            <input type="number" :value="getPrimarySite().y" @input="e => updateMultiCoords('y', parseFloat(e.target.value))" step="0.01">
                        </div>
                    </div>
                </div>
                <div class="control-group">
                    <label style="color:var(--accent)">{{ ui.layoutStyle }}</label>
                    <label>{{ ui.gridGap }}</label>
                    <div class="row" style="margin-bottom:5px"><input type="range" v-model.number="gap" min="0" max="100" style="flex:2" @input="render"><span class="val-display">{{gap}}</span></div>
                    <label style="margin-top:15px">{{ ui.radius }}</label>
                    <div class="row"><input type="range" v-model.number="cornerRadius" min="0" max="150" @input="render"><span class="val-display">{{cornerRadius}}</span></div>
                    <div class="row" style="margin-top:15px; border-top:1px solid #444; padding-top:10px;">
                        <input type="checkbox" id="cbImgBorder" v-model="imgBorder" @change="render"><label for="cbImgBorder" style="font-weight:bold;">{{ ui.imgBorder }}</label>
                    </div>
                    <div v-if="imgBorder">
                        <div class="row"><input type="color" v-model="imgBorderColor" style="flex:1" @input="render"><input type="range" v-model.number="imgBorderWidth" min="1" max="50" style="flex:2" @input="render"><span class="val-display">{{imgBorderWidth}}</span></div>
                        <label>{{ ui.borderAlpha }}</label>
                        <div class="row"><input type="range" v-model.number="imgBorderAlpha" min="0" max="1" step="0.01" @input="render"><span class="val-display">{{(imgBorderAlpha*100).toFixed(0)}}%</span></div>
                    </div>
                    <div class="row" style="margin-top:15px"><input type="checkbox" id="cbBorder" v-model="showBorders" @change="render"><label for="cbBorder" style="font-size:14px; color:white;">{{ ui.showGuides }}</label></div>
                    <div class="row"><input type="checkbox" id="cbMerge" v-model="mergeInternal" @change="render"><label for="cbMerge" style="font-size:14px; color:white;">{{ ui.seamlessMode }}</label></div>
                </div>
            </div>

            <!-- 4. åœ–ç‰‡æ¨¡å¼ (å«å®Œæ•´å¤šé¸æ§åˆ¶é …) -->
            <div v-if="mode === 'image'">
                <div v-if="selectedImgId && !isSwapping" class="control-group selected-panel" style="margin-bottom: 10px;">
                    <div class="info-header">{{ ui.imgInfo }}</div>
                    <div class="info-grid">
                        <span class="info-label">{{ ui.fileSize }}:</span><span class="info-val">{{ formatSize(getSelectedImg().size) }}</span>
                        <span class="info-label">{{ ui.fileName }}:</span><span class="info-val">{{ getSelectedImg().name || 'æœªå‘½å' }} <span v-if="getSelectedImg().isEmpty" style="color:#aaa">({{ ui.emptyCell }})</span></span>
                        <span class="info-label">{{ ui.lastMod }}:</span><span class="info-val">{{ formatDate(getSelectedImg().lastModified) }}</span>
                        <span class="info-label">{{ ui.dimensions }}:</span><span class="info-val">{{ getSelectedImg().obj ? getSelectedImg().obj.width + ' x ' + getSelectedImg().obj.height : '-' }}</span>
                    </div>
                </div>
                <div v-if="isSwapping" class="control-group selected-panel" style="border-color: #00e5ff; background: rgba(0, 229, 255, 0.1);"><label style="color: #00e5ff; font-size:14px; text-align:center;">{{ ui.swapInstruction }}</label></div>
                <div class="control-group" :class="{ 'disabled-block': !selectedImgId && !isSwapping, 'selected-panel': selectedImgId }">
                    <label :style="{color: selectedImgId ? 'var(--accent)' : '#aaa'}">{{ ui.imgTools }} ({{ selectedImgId ? ui.selected : ui.unselected }})</label>
                    <div v-if="!isSwapping">
                        <button class="secondary" style="margin-bottom:8px;" :disabled="!selectedImgId" @click="$refs.replaceInput.click()">ğŸ“ {{ ui.replaceImg }}</button>
                        <input type="file" ref="replaceInput" accept="image/*" style="display:none" @change="replaceImage">
                        <button class="col" :disabled="!selectedImgId" @click="activateSwapMode">ğŸ” {{ ui.swapPos }}</button>
                        <div style="height:10px"></div>
                        <label>{{ ui.scale }}</label>
                        <div class="row">
                            <input type="range" :value="getSelectedImg().scale" :disabled="!selectedImgId" min="0.1" max="5" step="0.05" @input="e => updateMultiImage('scale', e.target.value)">
                            <span class="val-display">{{ (getSelectedImg().scale || 1).toFixed(2) }}</span>
                        </div>
                        <label>{{ ui.rotate }}</label>
                        <div class="row">
                            <input type="range" :value="getSelectedImg().rotation" :disabled="!selectedImgId" min="-180" max="180" @input="e => updateMultiImage('rotation', e.target.value)">
                            <span class="val-display">{{ (getSelectedImg().rotation || 0).toFixed(0) }}Â°</span>
                        </div>
                        <button class="secondary" :disabled="!selectedImgId" @click="centerImg">ğŸ¯ {{ ui.resetCenter }}</button>
                        <div class="row">
                            <button class="secondary col" :disabled="!selectedImgId" @click="flipImg">â†” {{ ui.flip }}</button>
                            <button class="danger col" :disabled="!selectedImgId" @click="clearImgContent">ğŸ—‘ï¸ {{ lang === 'zh' ? 'æ¸…ç©ºå…§å®¹' : 'Clear Content' }}</button>
                        </div>
                        <button class="danger" style="margin-top:10px" :disabled="!selectedImgId" @click="deleteImg">ğŸ—‘ï¸ {{ ui.delCell }}</button>
                    </div>
                    <button v-if="isSwapping" class="secondary" @click="cancelSwap">{{ ui.cancelSwap }}</button>
                </div>
            </div>
            <!-- 5. å…¨åŸŸè¨­å®šæ¨¡å¼ (ç”±åº•éƒ¨ç§»è‡³æ­¤è™•) -->
            <div v-if="mode === 'settings'">
                <div class="control-group">
                    <label style="color:var(--accent)">{{ ui.canvasSize }}</label>
                    <div class="row compact">
                        <div class="col">
                            <label>{{ ui.width }}</label>
                            <input type="number" v-model.number="outWidth" @change="render">
                        </div>
                        <div class="col">
                            <label>{{ ui.height }}</label>
                            <input type="number" v-model.number="outHeight" @change="render">
                        </div>
                    </div>
                </div>

                <div class="control-group">
                    <label style="color:var(--accent)">{{ ui.margin }} (T / B / L / R)</label>
                    <div class="row compact">
                        <div class="col"><input type="number" v-model.number="marginTop" @input="render" placeholder="T"></div>
                        <div class="col"><input type="number" v-model.number="marginBottom" @input="render" placeholder="B"></div>
                        <div class="col"><input type="number" v-model.number="marginLeft" @input="render" placeholder="L"></div>
                        <div class="col"><input type="number" v-model.number="marginRight" @input="render" placeholder="R"></div>
                    </div>
                </div>

                <div class="control-group">
                    <label style="color:var(--accent)">{{ ui.bgSettings }}</label>
                    <div class="bg-tabs">
                        <div class="bg-tab" :class="{active: bgType==='solid'}" @click="bgType='solid'; render()">{{ ui.bgSolid }}</div>
                        <div class="bg-tab" :class="{active: bgType==='gradient'}" @click="bgType='gradient'; render()">{{ ui.bgGrad }}</div>
                    </div>
                    <div v-if="bgType==='solid'">
                        <label>{{ ui.color }}</label><input type="color" v-model="bgColor1" style="width:100%; height:40px; margin-bottom:5px;" @input="render">
                        <label>{{ ui.opacity }}</label><div class="row"><input type="range" v-model.number="bgAlpha1" min="0" max="1" step="0.01" @input="render"><span class="val-display">{{(bgAlpha1*100).toFixed(0)}}%</span></div>
                    </div>
                    <div v-if="bgType==='gradient'">
                        <label>{{ ui.color }} 1</label><div class="row"><input type="color" v-model="bgColor1" style="flex:1" @input="render"><input type="range" v-model.number="bgAlpha1" min="0" max="1" step="0.01" style="flex:2" @input="render"><span class="val-display">{{(bgAlpha1*100).toFixed(0)}}%</span></div>
                        <label>{{ ui.color }} 2</label><div class="row"><input type="color" v-model="bgColor2" style="flex:1" @input="render"><input type="range" v-model.number="bgAlpha2" min="0" max="1" step="0.01" style="flex:2" @input="render"><span class="val-display">{{(bgAlpha2*100).toFixed(0)}}%</span></div>
                        <label>{{ ui.angle }}</label><div class="row"><input type="range" v-model.number="bgAngle" min="0" max="360" @input="render"><span class="val-display">{{bgAngle}}Â°</span></div>
                    </div>
                </div>
            </div>
        </div>

        <!-- C. å›ºå®šåº•åº§ (å«æ”¶é—”åŠŸèƒ½) -->
        <div class="sidebar-fixed">
            <h2 @click="isBottomCollapsed = !isBottomCollapsed" 
                style="margin-bottom: 10px; font-size: 13px; color: #888; display: flex; justify-content: space-between; align-items: center; cursor: pointer;">
                {{ ui.fileOps }}
                <span style="font-size: 10px;">{{ isBottomCollapsed ? 'â–² EXPAND' : 'â–¼ COLLAPSE' }}</span>
            </h2>

            <!-- 1. æ”¶é—”ç‹€æ…‹ï¼šåƒ…é¡¯ç¤º 4 å€‹ç²¾ç°¡æŒ‰éˆ• -->
            <div v-if="isBottomCollapsed" class="row" style="gap: 5px; margin-bottom: 0;">
                <button class="col secondary" @click="undo" :disabled="historyIndex <= 0" title="Undo" style="padding: 10px 0;">â†©ï¸</button>
                <button class="col secondary" @click="redo" :disabled="historyIndex >= history.length - 1" title="Redo" style="padding: 10px 0;">â†ªï¸</button>
                <button class="col secondary" @click="$refs.fileInput.click()" title="Add Images" style="padding: 10px 0;">â•</button>
                <button class="col secondary" @click="saveProject" title="Save Project" style="padding: 10px 0;">ğŸ’¾</button>
            </div>

            <!-- 2. å±•é–‹ç‹€æ…‹ï¼šåŸå§‹å®Œæ•´æŒ‰éˆ•é¢æ¿ -->
            <div v-else>
                <div class="row">
                    <button class="col secondary" @click="undo" :disabled="historyIndex <= 0">â†©ï¸ {{ lang==='zh'?'å¾©åŸ':'Undo' }}</button>
                    <button class="col secondary" @click="redo" :disabled="historyIndex >= history.length - 1">â†ªï¸ {{ lang==='zh'?'é‡åš':'Redo' }}</button>
                </div>
                <div class="row" style="margin-top: 10px;">
                    <button class="col" @click="$refs.fileInput.click()">â• {{ ui.addImages }}</button>
                    <button class="col secondary" @click="$refs.relinkInput.click()">ğŸ“‚ {{ ui.relink }}</button>
                    <input type="file" ref="relinkInput" multiple accept="image/*" style="display:none" @change="handleRelink">
                </div>
                <input type="file" ref="fileInput" multiple accept="image/*" style="display:none" @change="handleFiles">
                <div class="row">
                    <button class="secondary col" @click="askReset">{{ ui.resetLayout }}</button>
                    <button class="secondary col" @click="askClear">{{ ui.clearAll }}</button>
                </div>
                <div class="row" style="margin-top:10px">
                    <button class="secondary col" @click="saveProject">ğŸ’¾ {{ ui.saveProj }}</button>
                    <button class="secondary col" @click="$refs.loadInput.click()">ğŸ“‚ {{ ui.loadProj }}</button>
                    <input type="file" ref="loadInput" accept=".json" style="display:none" @change="loadProject">
                </div>
            </div>

            <div class="btn-sticker-wrapper">
                <div class="pixel-sticker state-idle playing" v-html="pixelIdle"></div>
                <div class="pixel-sticker state-hover playing" v-html="pixelHover"></div>
                <button style="width:100%; background:white; color:black; margin-top:0; padding-top:10px; padding-bottom:10px; padding-left:30px;" @click="download">
                     {{ ui.download }}
                </button>
            </div>
        </div>
    </div> <!-- .sidebar çµæŸ -->

    <!-- D. ç•«å¸ƒå€åŸŸ (å«æ‹–æ”¾ä¸Šå‚³ã€æ‰‹æŸ„ã€ä½œè€…é€£çµ) -->
    <div class="canvas-area" 
        :class="{ connecting: isConnecting }"
         @contextmenu.prevent
         @mousedown="handleStart"  
         @mousemove="handleMove" 
         @mouseup="handleEnd" 
         @dblclick="handleDblClick" 
         @wheel="handleWheel"
         @touchstart="handleStart" 
         @touchmove.prevent="handleMove" 
         @touchend="handleEnd"
         @drop.prevent="handleDrop" 
         @dragover.prevent>
        
        <!-- å®Œæ•´æµ®å‹•æŠ½å±œç³»çµ± - æ˜ å°„æ‰€æœ‰å´é‚Šæ¬„åŠŸèƒ½ -->

        <!-- å·¦ä¸Šè§’é–‹å•Ÿä¸‰è§’å½¢ (åƒ…åœ¨æ”¶é—”æ™‚å‡ºç¾) -->
        <div v-if="isSidebarCollapsed" class="sidebar-open-triangle" @click.stop="toggleSidebar" title="æ‰“é–‹é¸å–®"></div>

        <!-- é ‚éƒ¨å·¥å…·æŠ½å±œçµ„ (å…¨é›™èªæ”¯æ´ç‰ˆ) -->
<div v-if="isSidebarCollapsed" class="floating-drawer-top" @mousedown.stop @touchstart.stop @touchmove.stop style="margin-top: 45px;">
    <!-- æ¨¡å¼åˆ‡æ› -->
    <div class="drawer-group">
            <button class="drawer-main-btn" :class="{active: activeDrawer==='mode'}" @click.stop="activeDrawer = activeDrawer==='mode'?null:'mode'">
            {{ mode === 'layout' ? 'ğŸ”§' : (mode === 'image' ? 'ğŸ–¼ï¸' : (mode === 'text' ? 'ğŸ“' : (mode === 'template' ? 'ğŸ§©' : 'âš™ï¸'))) }}
        </button>
            <div v-if="activeDrawer === 'mode'" class="drawer-content" @mousedown.stop>
            <label>{{ ui.modeSwitch }}</label>
            <button class="secondary" @click="setMode('layout'); activeDrawer=null">ğŸ”§ {{ ui.modeLayout }}</button>
            <button class="secondary" @click="setMode('image'); activeDrawer=null">ğŸ–¼ï¸ {{ ui.modeImage }}</button>
            <button class="secondary" @click="setMode('text'); activeDrawer=null">ğŸ“ {{ ui.modeText }}</button>
            <button class="secondary" @click="setMode('template'); activeDrawer=null">ğŸ§© {{ ui.modeTemplate }}</button>
            <button class="secondary" @click="setMode('settings'); activeDrawer=null">âš™ï¸ {{ ui.globalSettings }}</button>
        </div>
    </div>

    <div style="height:1px; background:rgba(255,255,255,0.2); margin:2px 0;"></div>

    <!-- --- A. æ¨¡æ¿æ¨¡å¼æŒ‰éˆ•çµ„ --- -->
    <template v-if="mode === 'template'">
        <div class="drawer-group">
            <button class="drawer-main-btn" :class="{active: activeDrawer==='tpl_set'}" @click.stop="activeDrawer = activeDrawer==='tpl_set'?null:'tpl_set'">âš™ï¸</button>
            <div v-if="activeDrawer === 'tpl_set'" class="drawer-content">
                <label>{{ ui.tplSettings }}</label>
                <label>Center X / Y</label>
                <div class="row compact">
                    <div class="col"><input type="number" v-model.number="tplCenterX" @input="updateTemplate"></div>
                    <div class="col"><input type="number" v-model.number="tplCenterY" @input="updateTemplate"></div>
                    <button class="secondary small-btn" @click="resetTplCenter">ğŸ¯</button>
                </div>
                <label>{{ ui.nodeCount || 'Count' }} ({{ tplCount }})</label>
                <input type="range" v-model.number="tplCount" min="1" max="50" step="1" @input="updateTemplate">
                <label>{{ ui.tplSpacing }} ({{ tplPadding }})</label>
                <input type="range" v-model.number="tplPadding" min="50" max="500" @input="updateTemplate">
                <label>{{ ui.tplRoundness }} ({{ tplSpacing }})</label>
                <input type="range" v-model.number="tplSpacing" min="1" max="20" @input="updateTemplate">
                <label>{{ ui.tplJitter }} ({{ tplJitter }})</label>
                <input type="range" v-model.number="tplJitter" min="0" max="20" @input="updateTemplate">
            </div>
        </div>
        <div class="drawer-group">
            <button class="drawer-main-btn" :class="{active: activeDrawer==='tpl_pre'}" @click.stop="activeDrawer = activeDrawer==='tpl_pre'?null:'tpl_pre'">ğŸŒ¸</button>
            <div v-if="activeDrawer === 'tpl_pre'" class="drawer-content">
                <label>{{ ui.tplSelect }}</label>
                <div class="row compact">
                    <button class="col secondary small-btn" @click="applyPreset('flower')">ğŸ• {{ ui.tplFlower }}</button>
                    <button class="col secondary small-btn" @click="applyPreset('radial')">â˜€ {{ ui.tplRadial }}</button>
                    <button class="col secondary small-btn" @click="applyPreset('grid')">â–¦ {{ ui.tplGrid }}</button>
                </div>
                <div class="row compact">
                    <button class="col secondary small-btn" @click="applyPreset('circle')">ğŸ¥ {{ ui.tplCircle }}</button>
                    <button class="col secondary small-btn" @click="applyPreset('honeycomb')">âœ¿ {{ ui.tplHoneycomb }}</button>
                    <button class="col secondary small-btn" @click="applyPreset('masonry')">ğŸ’¥ {{ ui.tplMasonry }}</button>
                </div>
            </div>
        </div>
    </template>

    <!-- --- B. æ–‡å­—æ¨¡å¼æŒ‰éˆ•çµ„ --- -->
    <template v-if="mode === 'text'">
        <div class="drawer-group">
            <button class="drawer-main-btn" :class="{active: activeDrawer==='txt_add'}" @click.stop="activeDrawer = activeDrawer==='txt_add'?null:'txt_add'">â•</button>
            <div v-if="activeDrawer === 'txt_add'" class="drawer-content">
                <label>{{ ui.addObject }}</label>
                <button @click="addText">â• {{ ui.addText }}</button>
                <button @click="$refs.stickerInput.click()">ğŸ–¼ï¸ {{ lang==='zh'?'è²¼åœ–':'Sticker' }}</button>
                <button class="secondary" @click="duplicateText">ğŸ“‘ {{ ui.copyText }}</button>
            </div>
        </div>
        <div v-if="selectedTextId || selectedStickerId" class="drawer-group">
            <button class="drawer-main-btn" :class="{active: activeDrawer==='txt_edit'}" @click.stop="activeDrawer = activeDrawer==='txt_edit'?null:'txt_edit'">ğŸ“</button>
            <div v-if="activeDrawer === 'txt_edit'" class="drawer-content">
                <template v-if="selectedTextId">
                    <label>{{ ui.editContent }}</label>
                    <textarea :value="getSelectedText().content" @input="e => updateTextModeTransform('content', e.target.value)"></textarea>
                    <div class="row compact">
                        <div class="col"><label>X</label><input type="number" :value="getSelectedText().x" @input="e => updateTextModeTransform('x', e.target.value)"></div>
                        <div class="col"><label>Y</label><input type="number" :value="getSelectedText().y" @input="e => updateTextModeTransform('y', e.target.value)"></div>
                    </div>
                    <div class="row compact">
                        <div class="col"><label>{{ ui.size }}</label><input type="number" :value="getSelectedText().fontSize" @input="e => updateTextModeTransform('fontSize', e.target.value)"></div>
                        <div class="col"><label>{{ ui.rotate }}</label><input type="number" :value="getSelectedText().rotation" @input="e => updateTextModeTransform('rotation', e.target.value)"></div>
                    </div>
                    <label>{{ ui.color }}</label>
                    <input type="color" :value="getSelectedText().color" @input="e => updateTextModeTransform('color', e.target.value)" style="width:100%; height:35px;">
                    <label>{{ ui.style }}</label>
                    <div class="row">
                        <button class="secondary small-btn" :style="{background: getSelectedText().isBold ? '#666' : '#333'}" @click="toggleText('isBold')">B</button>
                        <button class="secondary small-btn" :style="{background: getSelectedText().isItalic ? '#666' : '#333'}" @click="toggleText('isItalic')">I</button>
                        <button class="secondary small-btn" :style="{background: getSelectedText().isUnderlined ? '#666' : '#333'}" @click="toggleText('isUnderlined')">U</button>
                        <button class="secondary small-btn" :style="{background: getSelectedText().isVertical ? '#666' : '#333'}" @click="toggleText('isVertical')">|||</button>
                    </div>
                </template>
                <template v-if="selectedStickerId">
                    <label>{{ ui.stickerSettings }}</label>
                    <div class="row compact">
                        <div class="col"><label>X</label><input type="number" :value="getSelectedSticker().x" @input="e => updateTextModeTransform('x', e.target.value)"></div>
                        <div class="col"><label>Y</label><input type="number" :value="getSelectedSticker().y" @input="e => updateTextModeTransform('y', e.target.value)"></div>
                    </div>
                    <label>{{ ui.scale }}</label>
                    <input type="range" :value="getSelectedSticker().scale" min="0.1" max="5" step="0.1" @input="e => updateTextModeTransform('scale', e.target.value)">
                <label>{{ ui.rotate }}</label>
                <input type="range" :value="getSelectedSticker().rotation" min="-180" max="180" @input="e => updateTextModeTransform('rotation', e.target.value)">
                </template>
                <button class="danger" style="margin-top:10px" @click="selectedTextId?deleteText():deleteSticker()">ğŸ—‘ï¸ {{ ui.delete }}</button>
            </div>
        </div>
        <div v-if="selectedTextId" class="drawer-group">
            <button class="drawer-main-btn" :class="{active: activeDrawer==='txt_font'}" @click.stop="activeDrawer = activeDrawer==='txt_font'?null:'txt_font'">ğŸ”¤</button>
            <div v-if="activeDrawer === 'txt_font'" class="drawer-content">
                <label>{{ ui.fontFamily }}</label>
                <button class="secondary small-btn" @click="$refs.fontInput.click()">ğŸ“ {{ ui.importFont }}</button>
                <label>{{ ui.textStroke }}</label>
                <div class="row">
                    <input type="color" :value="getSelectedText().strokeColor" @input="e => updateTextModeTransform('strokeColor', e.target.value)" style="flex:1">
                    <input type="range" :value="getSelectedText().strokeWidth" @input="e => updateTextModeTransform('strokeWidth', e.target.value)" min="0" max="20" style="flex:2">
                </div>
            </div>
        </div>
        <div v-if="selectedTextId" class="drawer-group">
            <button class="drawer-main-btn" :class="{active: activeDrawer==='txt_transform'}" @click.stop="activeDrawer = activeDrawer==='txt_transform'?null:'txt_transform'">ğŸ”„</button>
            <div v-if="activeDrawer === 'txt_transform'" class="drawer-content">
                <label>{{ ui.transformControl }}</label>
                <div class="row compact">
                    <div class="col"><label>{{ ui.skewX }}</label><input type="number" :value="getSelectedText().skewX" @input="e => updateTextModeTransform('skewX', e.target.value)"></div>
                    <div class="col"><label>{{ ui.skewY }}</label><input type="number" :value="getSelectedText().skewY" @input="e => updateTextModeTransform('skewY', e.target.value)"></div>
                </div>
            </div>
        </div>
    </template>

    <!-- --- C. æ’ç‰ˆæ¨¡å¼æŒ‰éˆ•çµ„ --- -->
    <template v-if="mode === 'layout'">
        <!-- ç¨ç«‹æŒ‰éˆ• 1ï¼šæ–°å¢æ–¹æ ¼ -->
        <div class="drawer-group">
            <button 
                class="drawer-main-btn" 
                :title="ui.addEmpty"
                @click.stop="addEmptyCell"
            >
                ğŸ”²
            </button>
        </div>
        <div v-if="selectedImgId" class="drawer-group">
            <button class="drawer-main-btn" :class="{active: activeDrawer==='lay_node'}" @click.stop="activeDrawer = activeDrawer==='lay_node'?null:'lay_node'">ğŸ”—</button>
            <div v-if="activeDrawer === 'lay_node'" class="drawer-content">
                <label>{{ ui.nodeControl }}</label>
                <div class="row">
                    <button class="col" @click="addPoint">â• {{ ui.addPoint }}</button>
                    <button class="secondary col" @click="removePoint">â– {{ ui.removePoint }}</button>
                </div>
                <button :class="{'btn-active': isConnecting}" @click="toggleConnectMode">ğŸ”— {{ ui.connectNode }}</button>

                <template v-if="selectedSiteIds.length > 0">
                    <label style="color: #00ffaa; margin-top: 10px; border-top: 1px solid #444; padding-top: 10px;">
                        {{ lang === 'zh' ? 'ç²¾æº–åº§æ¨™' : 'Coords' }} <span style="font-size:10px; color:#888">({{ selectedSiteIds.length }})</span>
                    </label>
                    <div class="row compact">
                        <div class="col">
                            <label>X</label>
                            <input type="number" :value="getPrimarySite().x" @input="e => updateMultiCoords('x', parseFloat(e.target.value))" step="0.01">
                        </div>
                        <div class="col">
                            <label>Y</label>
                            <input type="number" :value="getPrimarySite().y" @input="e => updateMultiCoords('y', parseFloat(e.target.value))" step="0.01">
                        </div>
                    </div>
                </template>
            </div>
        </div>
        <div class="drawer-group">
            <button class="drawer-main-btn" :class="{active: activeDrawer==='lay_sty'}" @click.stop="activeDrawer = activeDrawer==='lay_sty'?null:'lay_sty'">ğŸ¨</button>
            <div v-if="activeDrawer === 'lay_sty'" class="drawer-content" @mousedown.stop>
                <label>{{ ui.layoutStyle }}</label>
                <label>{{ ui.gridGap }} ({{gap}})</label>
                <input type="range" v-model.number="gap" min="0" max="100" @input="render">
                <label>{{ ui.radius }} ({{cornerRadius}})</label>
                <input type="range" v-model.number="cornerRadius" min="0" max="150" @input="render">
                
                <!-- ä¿®æ­£å¾Œçš„å‹¾é¸æ¬„ç›® 1 -->
                <div class="row" style="margin-top:10px" @click.stop>
                    <input type="checkbox" id="draw_showBorders" v-model="showBorders" @change="render" @click.stop>
                    <label for="draw_showBorders" style="margin:0; cursor:pointer;">{{ ui.showGuides }}</label>
                </div>
                
                <!-- ä¿®æ­£å¾Œçš„å‹¾é¸æ¬„ç›® 2 -->
                <div class="row" @click.stop>
                    <input type="checkbox" id="draw_mergeInternal" v-model="mergeInternal" @change="render" @click.stop>
                    <label for="draw_mergeInternal" style="margin:0; cursor:pointer;">{{ ui.seamlessMode }}</label>
                </div>
            </div>
        </div>
        <!-- ç¨ç«‹æŒ‰éˆ• 2ï¼šåˆªé™¤æ–¹æ ¼ -->
        <div class="drawer-group">
            <button 
                class="drawer-main-btn danger-btn" 
                :class="{ 'disabled-btn': !selectedImgId }"
                :title="ui.delCell"
                :disabled="!selectedImgId"
                @click.stop="deleteImg"
            >
                ğŸ—‘ï¸
            </button>
        </div>
    </template>

    <!-- --- D. åœ–ç‰‡æ¨¡å¼æŒ‰éˆ•çµ„ (åŠŸèƒ½è£œå®Œç‰ˆ) --- -->
    <template v-if="mode === 'image' && selectedImgId">
        <!-- 1. åœ–ç‰‡å·¥å…·æŠ½å±œ -->
        <div class="drawer-group">
                <button class="drawer-main-btn" :class="{active: activeDrawer==='img_tool'}" 
                    @click.stop="activeDrawer = activeDrawer==='img_tool'?null:'img_tool'">ğŸ› ï¸</button>
                <div v-if="activeDrawer === 'img_tool'" class="drawer-content">
                <label>{{ ui.imgTools }}</label>
                <!-- æ›´æ›èˆ‡äº¤æ›æŒ‰éˆ• -->
                <button class="secondary" @click.stop="$refs.replaceInput.click()">ğŸ“ {{ ui.replaceImg }}</button>
                <button @click.stop="activateSwapMode">ğŸ” {{ ui.swapPos }}</button>
                
                <div style="height:8px"></div>
                
                <!-- ç¸®æ”¾æ‹‰æ¡¿ -->
                <label>{{ ui.scale }} ({{ (getSelectedImg().scale || 1).toFixed(2) }})</label>
                  <input type="range" :value="getSelectedImg().scale" min="0.1" max="5" step="0.05" 
                      @input="e => updateMultiImage('scale', e.target.value)">
                
                <!-- æ—‹è½‰æ‹‰æ¡¿ (åŸæœ¬ç¼ºå¤±) -->
                <label>{{ ui.rotate }} ({{ (getSelectedImg().rotation || 0).toFixed(0) }}Â°)</label>
                  <input type="range" :value="getSelectedImg().rotation" min="-180" max="180" step="1" 
                      @input="e => updateMultiImage('rotation', e.target.value)">
                
                <!-- å›åˆ°æ­£ä¸­ (åŸæœ¬ç¼ºå¤±) -->
                <button class="secondary" @click.stop="centerImg">ğŸ¯ {{ ui.resetCenter }}</button>

                <!-- ç¿»è½‰èˆ‡æ¸…ç©º (åŸæœ¬ç¼ºå¤±æ¸…ç©º) -->
                <div class="row compact">
                    <button class="secondary col" @click.stop="flipImg">â†” {{ ui.flip }}</button>
                    <button class="danger col" @click.stop="clearImgContent">ğŸ§¹ {{ lang === 'zh' ? 'æ¸…ç©º' : 'Clear' }}</button>
                </div>

                <button class="danger" style="margin-top:10px" @click.stop="deleteImg">ğŸ—‘ï¸ {{ ui.delCell }}</button>
            </div>
        </div>
         <!-- 2. åœ–ç‰‡è³‡è¨ŠæŠ½å±œ (åŸæœ¬ç¼ºå¤±) -->
        <div class="drawer-group">
                <button class="drawer-main-btn" :class="{active: activeDrawer==='img_info'}" 
                    @click.stop="activeDrawer = activeDrawer==='img_info'?null:'img_info'">â„¹ï¸</button>
                <div v-if="activeDrawer === 'img_info'" class="drawer-content">
                <label style="color:var(--accent)">{{ ui.imgInfo }}</label>
                <div class="info-grid" style="margin-top:5px; gap: 8px 5px;">
                    <span class="info-label">{{ ui.fileName }}:</span>
                    <span class="info-val" style="font-size:10px;">{{ getSelectedImg().name || '-' }}</span>
                    
                    <span class="info-label">{{ ui.fileSize }}:</span>
                    <span class="info-val">{{ formatSize(getSelectedImg().size) }}</span>
                    
                    <span class="info-label">{{ ui.dimensions }}:</span>
                    <span class="info-val">{{ getSelectedImg().obj ? getSelectedImg().obj.width + 'x' + getSelectedImg().obj.height : '-' }}</span>
                </div>
            </div>
        </div>
    </template>

    <!-- --- E. å…¨åŸŸè¨­å®šæŒ‰éˆ•çµ„ --- -->
    <template v-if="mode === 'settings'">
        <div class="drawer-group">
            <button class="drawer-main-btn" :class="{active: activeDrawer==='set_can'}" @click.stop="activeDrawer = activeDrawer==='set_can'?null:'set_can'">ğŸ“</button>
            <div v-if="activeDrawer === 'set_can'" class="drawer-content">
                <label>{{ ui.canvasSize }}</label>
                <div class="row compact">
                    <div class="col"><input type="number" v-model.number="outWidth" @change="render"></div>
                    <span style="color:#888; font-size:10px;">x</span>
                    <div class="col"><input type="number" v-model.number="outHeight" @change="render"></div>
                </div>
            </div>
        </div>
        <div class="drawer-group">
            <button class="drawer-main-btn" :class="{active: activeDrawer==='set_bg'}" @click.stop="activeDrawer = activeDrawer==='set_bg'?null:'set_bg'">ğŸŒˆ</button>
            <div v-if="activeDrawer === 'set_bg'" class="drawer-content">
                <label>{{ ui.bgSettings }}</label>
                <button class="secondary" @click="bgType='solid'; render()">{{ ui.bgSolid }}</button>
                <button class="secondary" @click="bgType='gradient'; render()">{{ ui.bgGrad }}</button>
                <label>{{ ui.color }}</label>
                <input type="color" v-model="bgColor1" @input="render" style="width:100%; height:35px;">
            </div>
        </div>
    </template>
</div>
    <!-- åº•éƒ¨å·¥å…·å€ (å…¨é›™èªæ”¯æ´ç‰ˆ) -->
     <div v-show="isSidebarCollapsed" 
         class="floating-drawer-top-right" 
         @mousedown.stop
         @touchstart.stop
         @touchmove.stop>
        
        <!-- æª”æ¡ˆæ“ä½œé¸å–® (ç§»è‡³æœ€ä¸Šæ–¹) -->
        <div class="drawer-group">
            <button class="drawer-main-btn" :class="{active: activeDrawer==='file_menu'}" @click.stop="activeDrawer = activeDrawer==='file_menu'?null:'file_menu'">ğŸ’¾</button>
            <div v-if="activeDrawer === 'file_menu'" class="drawer-content" @mousedown.stop>
                <label>{{ ui.fileOps }}</label>
                <button @click="saveProject">ğŸ’¾ {{ ui.saveProj }}</button>
                <button class="secondary" @click="$refs.loadInput.click()">ğŸ“‚ {{ ui.loadProj }}</button>
                <button class="secondary" @click="$refs.relinkInput.click()">ğŸ”— {{ ui.relink }}</button>
                <button style="background:white; color:black; margin-top:10px;" @click="download">ğŸ“¥ {{ ui.download }}</button>
                <button class="danger" style="margin-top:10px" @click="askClear">ğŸ—‘ï¸ {{ ui.clearAll }}</button>
            </div>
        </div>

        <div style="height:1px; background:rgba(255,255,255,0.2); margin:2px 0;"></div>

        <!-- ç›´æ¥åŸ·è¡Œï¼šå¾©åŸ -->
        <div class="drawer-group">
            <button class="drawer-main-btn" :disabled="historyIndex <= 0" @click.stop="undo" :title="ui.undo">â†©ï¸</button>
        </div>

        <!-- ç›´æ¥åŸ·è¡Œï¼šé‡åš -->
        <div class="drawer-group">
            <button class="drawer-main-btn" :disabled="historyIndex >= history.length - 1" @click.stop="redo" :title="ui.redo">â†ªï¸</button>
        </div>

        <!-- ç›´æ¥åŸ·è¡Œï¼šåŠ å…¥åœ–ç‰‡ -->
        <div class="drawer-group">
            <button class="drawer-main-btn" @click.stop="$refs.fileInput.click()" :title="ui.addImages">â•</button>
        </div>
    </div>


        <div class="canvas-wrapper"
             :style="{ 
                width: outWidth + 'px', 
                height: outHeight + 'px', 
                transform: 'translate(' + panX + 'px, ' + panY + 'px) scale(' + viewZoom + ')' 
             }">

            <canvas ref="canvas" :width="outWidth" :height="outHeight"></canvas>

            <!-- ç¯€é»å±¤ï¼šå¥—ç”¨åå‘ç¸®æ”¾ä½¿å¤§å°ç¶­æŒå›ºå®š -->
            <div v-if="mode === 'layout'" v-for="s in sites" :key="'site-'+s.id" 
                     class="node-marker"
                     :style="{ 
                        left: s.x + 'px', 
                        top: s.y + 'px', 
                        background: getNodeColor(s),
                        width: (16 / viewZoom) + 'px', 
                        height: (16 / viewZoom) + 'px',
                        borderWidth: (1.5 / viewZoom) + 'px'
                     }">
            </div>
                
            <!-- æ‰‹æŸ„å±¤ï¼šå¥—ç”¨åå‘ç¸®æ”¾ä½¿å¤§å°ç¶­æŒå›ºå®š -->
            <div v-if="mode === 'text' && (selectedTextId || selectedStickerId) && textHandlePos" 
                     class="rotate-handle"
                     title="Drag to Rotate/Scale"
                     :style="{ 
                        left: textHandlePos.x + 'px', 
                        top: textHandlePos.y + 'px',
                        width: (28 / viewZoom) + 'px',
                        height: (28 / viewZoom) + 'px',
                        fontSize: (14 / viewZoom) + 'px',
                        borderWidth: (2 / viewZoom) + 'px'
                     }">
                â†»
            </div>

            <div v-if="isBoxSelecting" class="selection-box" :style="selectionBoxStyle"></div>

            <!-- è¼¸å…¥æ¡†ï¼šæ”¾åœ¨ Wrapper å…§æœƒè‡ªå‹•è·Ÿéš¨ç•«å¸ƒç¸®æ”¾ï¼Œæ–‡å­—å¤§å°å°‡èˆ‡ Canvas å®Œå…¨ä¸€è‡´ -->
            <textarea v-if="editingTextId" ref="floatInput" class="float-input"
                      v-model="tempTextContent" 
                      @blur="finishEdit" @keydown.enter.prevent="finishEdit"
                      :style="inputStyle"></textarea>
        </div>
                  
        <div class="zoom-ctrl" 
             :class="{ 'minimized': isSidebarCollapsed }" 
             @mousedown.stop @touchstart.stop @touchmove.stop>
            <span style="color:#aaa; font-size:12px;">Zoom</span>
            <input type="range" v-model.number="viewZoom" min="0.1" max="2" step="0.05">
            <span class="val-display" style="width:30px">{{ (viewZoom*100).toFixed(0) }}%</span>
            <button class="small-btn secondary" @click.stop="fitView" style="width:auto; margin:0;">Fit</button>
        </div>
        
        <a class="author-link" href="https://portaly.cc/dreamoon13" target="_blank">
            Created by Dreamoon-Q
        </a>
    </div> <!-- .canvas-area çµæŸ -->
</div> <!-- #app çµæŸ -->

<script>
    new Vue({
        el: '#app',
        data: {
            lang: 'zh',
            isSidebarCollapsed: false,
            activeDrawer: null,
            isGlobalSettingsOpen: true, 
            isConnecting: false,
            
        
            // å¹³å¸¸ç‹€æ…‹çš„å››å½±æ ¼ (Idle)
            pixelIdle: `
                <svg viewBox="0 0 37 49" xmlns="http://www.w3.org/2000/svg" shape-rendering="crispEdges">
                    <g class="frame-group f1"><path fill="#f1d492" d="M15 0h8v1h-8zM12 1h4v1h-4zM22 1h3v1h-3zM10 2h3v1h-3zM24 2h3v1h-3zM8 3h3v1h-3zM26 3h3v1h-3zM8 4h1v1h-1zM28 4h2v1h-2zM6 5h2v1h-2zM29 5h2v1h-2zM5 6h2v1h-2zM30 6h2v1h-2zM4 7h2v1h-2zM31 7h2v1h-2zM4 8h1v2h-1zM32 8h2v1h-2zM3 9h1v2h-1zM33 9h1v2h-1zM2 11h1v4h-1zM34 11h1v3h-1zM35 13h1v4h-1zM1 14h1v3h-1zM0 16h1v13h-1zM36 16h1v13h-1zM1 28h1v3h-1zM35 28h1v4h-1zM2 30h1v4h-1zM34 31h1v3h-1zM3 34h1v2h-1zM33 34h1v3h-1zM4 35h1v3h-1zM5 37h1v2h-1zM34 37h2v1h-2zM6 38h2v1h-2zM7 39h1v1h-1zM26 41h3v1h-3zM24 42h3v1h-3zM29 42h1v2h-1zM23 43h2v1h-2z"/>
                        <path fill="#3b302a" d="M11 12h3v1h-3zM10 13h1v3h-1zM14 13h1v1h-1zM9 15h1v7h-1zM11 15h8v1h-8zM6 16h1v1h-1zM11 16h1v1h-1zM13 16h8v3h-8zM7 17h1v1h-1zM12 17h1v1h-1zM21 17h1v7h-1zM23 17h2v1h-2zM8 18h1v1h-1zM11 18h1v1h-1zM23 18h1v1h-1zM25 18h1v3h-1zM6 19h1v2h-1zM10 19h1v6h-1zM12 19h5v1h-5zM18 19h3v6h-3zM22 19h1v4h-1zM24 19h1v2h-1zM26 19h1v1h-1zM5 20h1v3h-1zM7 20h1v9h-1zM14 20h2v2h-2zM17 20h1v5h-1zM16 21h1v3h-1zM4 22h1v6h-1zM8 22h1v9h-1zM15 22h1v1h-1zM6 23h1v10h-1zM5 24h1v7h-1zM22 24h1v1h-1zM11 25h1v2h-1zM18 25h2v2h-2zM21 25h1v1h-1zM12 27h1v1h-1zM19 27h1v1h-1z"/>
                        <path fill="#261f1b" d="M8 16h1v2h-1zM10 16h1v3h-1zM12 16h1v1h-1zM11 17h1v1h-1zM25 17h1v1h-1zM6 18h2v1h-2zM12 18h1v1h-1zM22 18h1v1h-1zM26 18h1v1h-1zM7 19h1v1h-1zM11 19h1v2h-1zM23 19h1v17h-1zM12 20h2v1h-2zM26 20h1v3h-1zM24 21h2v4h-2zM22 23h1v1h-1zM21 24h1v1h-1zM9 25h1v2h-1zM20 25h1v2h-1zM22 25h1v10h-1zM25 25h2v1h-2zM21 26h1v1h-1zM21 29h1v5h-1zM20 30h1v3h-1zM19 31h1v1h-1zM8 32h4v1h-4zM8 33h3v2h-3zM8 35h2v1h-2zM8 36h1v5h-1zM9 37h1v2h-1zM23 37h1v6h-1zM22 38h1v4h-1z"/>
                        <path fill="#635143" d="M24 18h1v1h-1zM8 19h1v3h-1zM17 19h1v1h-1zM16 20h1v1h-1zM6 21h1v2h-1zM5 23h1v1h-1z"/>
                        <path fill="#f5d2bc" d="M11 21h3v4h-3zM9 22h1v3h-1zM14 22h1v3h-1zM15 23h1v2h-1zM16 24h1v1h-1zM10 25h1v7h-1zM12 25h1v2h-1zM13 26h1v6h-1zM17 26h1v6h-1zM11 27h1v5h-1zM18 27h1v4h-1zM20 27h2v2h-2zM12 28h1v4h-1zM19 28h1v3h-1zM7 29h1v2h-1zM20 29h1v1h-1zM9 30h1v2h-1zM14 30h3v2h-3zM8 31h1v1h-1zM23 44h2v1h-2zM10 45h2v1h-2zM24 45h2v1h-2zM10 46h1v2h-1z"/>
                        <path fill="#372e27" d="M13 25h5v1h-5zM14 26h3v1h-3z"/>
                        <path fill="#7a5335" d="M9 27h1v1h-1zM15 27h2v1h-2z"/>
                        <path fill="#fbe8d7" d="M14 27h1v3h-1z"/>
                        <path fill="#a37042" d="M9 28h1v2h-1zM15 28h2v2h-2z"/>
                        <path fill="#d0c0b1" d="M18 31h1v1h-1zM12 32h5v1h-5zM11 33h3v1h-3zM11 34h2v1h-2zM10 35h2v2h-2zM9 36h1v1h-1zM18 36h1v4h-1zM23 36h1v1h-1zM10 37h1v3h-1zM22 37h1v1h-1zM19 39h1v1h-1z"/>
                        <path fill="#fafaf8" d="M17 32h3v4h-3zM14 33h3v7h-3zM20 33h1v6h-1zM13 34h1v6h-1zM21 34h1v5h-1zM12 35h1v5h-1zM22 35h1v2h-1zM17 36h1v4h-1zM19 36h1v3h-1zM11 37h1v3h-1z"/>
                        <path fill="#d59f87" d="M9 39h1v2h-1zM20 39h2v2h-2zM21 41h1v1h-1zM22 42h1v2h-1zM23 45h1v1h-1zM11 46h1v3h-1z"/>
                        <path fill="#1b1f28" d="M10 40h10v1h-10zM6 41h1v2h-1zM13 41h1v3h-1zM18 41h3v1h-3zM5 42h1v1h-1zM7 42h2v1h-2zM12 42h1v7h-1zM19 42h3v1h-3zM8 43h4v1h-4zM14 43h5v1h-5zM10 44h2v1h-2zM22 44h1v4h-1zM9 45h1v4h-1zM4 46h1v2h-1zM13 46h1v3h-1zM5 47h4v1h-4zM14 47h8v2h-8zM6 48h3v1h-3z"/>
                        <path fill="#2b3141" d="M7 41h6v1h-6zM14 41h2v2h-2zM17 41h1v2h-1zM9 42h3v1h-3zM16 42h1v1h-1zM18 42h1v1h-1zM4 43h4v3h-4zM19 43h3v4h-3zM8 44h2v1h-2zM13 44h6v2h-6zM8 45h1v2h-1zM5 46h3v1h-3zM14 46h5v1h-5z"/>
                        <path fill="#2a3040" d="M16 41h1v1h-1z"/>
                        <path fill="#d49e87" d="M10 48h1v1h-1z"/></g>
                    <g class="frame-group f2"><path fill="#f1d492" d="M15 0h8v1h-8zM12 1h4v1h-4zM22 1h3v1h-3zM10 2h3v1h-3zM24 2h3v1h-3zM8 3h3v1h-3zM26 3h3v1h-3zM8 4h1v1h-1zM28 4h2v1h-2zM6 5h2v1h-2zM29 5h2v1h-2zM5 6h2v1h-2zM30 6h2v1h-2zM4 7h2v1h-2zM31 7h2v1h-2zM4 8h1v2h-1zM32 8h2v1h-2zM3 9h1v2h-1zM33 9h1v2h-1zM2 11h1v4h-1zM34 11h1v3h-1zM35 13h1v4h-1zM1 14h1v3h-1zM0 16h1v13h-1zM36 16h1v13h-1zM1 28h1v3h-1zM35 28h1v4h-1zM2 30h1v4h-1zM34 31h1v3h-1zM3 34h1v2h-1zM33 34h1v3h-1zM4 35h1v3h-1zM5 37h1v2h-1zM34 37h2v1h-2zM6 38h2v1h-2zM7 39h1v1h-1zM26 41h3v1h-3zM24 42h3v1h-3zM29 42h1v2h-1zM23 43h2v1h-2z"/>
                        <path fill="#3b302a" d="M11 12h3v1h-3zM10 13h1v3h-1zM14 13h1v1h-1zM9 15h1v7h-1zM11 15h8v1h-8zM6 16h1v1h-1zM11 16h1v1h-1zM13 16h8v3h-8zM7 17h1v1h-1zM12 17h1v1h-1zM21 17h1v7h-1zM23 17h2v1h-2zM8 18h1v1h-1zM11 18h1v1h-1zM23 18h1v1h-1zM25 18h1v3h-1zM6 19h1v2h-1zM10 19h1v6h-1zM12 19h5v1h-5zM18 19h3v6h-3zM22 19h1v4h-1zM24 19h1v2h-1zM26 19h1v1h-1zM5 20h1v3h-1zM7 20h1v9h-1zM14 20h2v2h-2zM17 20h1v5h-1zM16 21h1v3h-1zM4 22h1v6h-1zM8 22h1v9h-1zM15 22h1v1h-1zM6 23h1v10h-1zM5 24h1v7h-1zM22 24h1v1h-1zM11 25h1v2h-1zM18 25h2v2h-2zM21 25h1v1h-1zM12 27h1v1h-1zM19 27h1v1h-1z"/>
                        <path fill="#261f1b" d="M8 16h1v2h-1zM10 16h1v3h-1zM12 16h1v1h-1zM11 17h1v1h-1zM25 17h1v1h-1zM6 18h2v1h-2zM12 18h1v1h-1zM22 18h1v1h-1zM26 18h1v1h-1zM7 19h1v1h-1zM11 19h1v2h-1zM23 19h1v17h-1zM12 20h2v1h-2zM26 20h1v3h-1zM24 21h2v4h-2zM22 23h1v1h-1zM21 24h1v1h-1zM9 25h1v2h-1zM20 25h1v2h-1zM22 25h1v10h-1zM25 25h2v1h-2zM21 26h1v1h-1zM21 29h1v5h-1zM20 30h1v3h-1zM19 31h1v1h-1zM8 32h4v1h-4zM8 33h3v2h-3zM8 35h2v1h-2zM8 36h1v5h-1zM9 37h1v2h-1zM23 37h1v6h-1zM22 38h1v4h-1z"/>
                        <path fill="#635143" d="M24 18h1v1h-1zM8 19h1v3h-1zM17 19h1v1h-1zM16 20h1v1h-1zM6 21h1v2h-1zM5 23h1v1h-1z"/>
                        <path fill="#f5d2bc" d="M11 21h3v4h-3zM9 22h1v3h-1zM14 22h1v3h-1zM15 23h1v2h-1zM16 24h1v1h-1zM10 25h1v7h-1zM12 25h1v2h-1zM13 26h1v6h-1zM17 26h1v6h-1zM11 27h1v5h-1zM18 27h1v4h-1zM20 27h2v2h-2zM12 28h1v4h-1zM19 28h1v3h-1zM7 29h1v2h-1zM20 29h1v1h-1zM9 30h1v2h-1zM14 30h3v2h-3zM8 31h1v1h-1zM23 44h2v1h-2zM10 45h2v1h-2zM24 45h2v1h-2zM10 46h1v2h-1z"/>
                        <path fill="#372e27" d="M13 25h5v1h-5zM14 26h3v1h-3z"/>
                        <path fill="#7a5335" d="M9 27h1v1h-1zM15 27h2v1h-2z"/>
                        <path fill="#fbe8d7" d="M14 27h1v3h-1z"/>
                        <path fill="#a37042" d="M9 28h1v2h-1zM15 28h2v2h-2z"/>
                        <path fill="#d0c0b1" d="M18 31h1v1h-1zM12 32h5v1h-5zM11 33h2v1h-2zM11 34h1v2h-1zM10 35h1v5h-1zM9 36h1v1h-1zM18 36h1v4h-1zM23 36h1v1h-1zM22 37h1v1h-1zM19 39h1v1h-1z"/>
                        <path fill="#fafaf8" d="M17 32h3v4h-3zM13 33h4v7h-4zM20 33h1v6h-1zM12 34h1v6h-1zM21 34h1v5h-1zM22 35h1v2h-1zM11 36h1v4h-1zM17 36h1v4h-1zM19 36h1v3h-1z"/>
                        <path fill="#d59f87" d="M9 39h1v2h-1zM20 39h2v2h-2zM21 41h1v1h-1zM22 42h1v2h-1zM23 45h1v1h-1zM11 46h1v3h-1z"/>
                        <path fill="#1b1f28" d="M10 40h10v1h-10zM6 41h1v2h-1zM13 41h1v3h-1zM18 41h3v1h-3zM5 42h1v1h-1zM7 42h2v1h-2zM12 42h1v7h-1zM19 42h3v1h-3zM8 43h4v1h-4zM14 43h5v1h-5zM10 44h2v1h-2zM22 44h1v4h-1zM9 45h1v4h-1zM4 46h1v2h-1zM13 46h1v3h-1zM5 47h4v1h-4zM14 47h8v2h-8zM6 48h3v1h-3z"/>
                        <path fill="#2b3141" d="M7 41h6v1h-6zM14 41h2v2h-2zM17 41h1v2h-1zM9 42h3v1h-3zM16 42h1v1h-1zM18 42h1v1h-1zM4 43h4v3h-4zM19 43h3v4h-3zM8 44h2v1h-2zM13 44h6v2h-6zM8 45h1v2h-1zM5 46h3v1h-3zM14 46h5v1h-5z"/>
                        <path fill="#2a3040" d="M16 41h1v1h-1z"/>
                        <path fill="#d49e87" d="M10 48h1v1h-1z"/></g>
                    <g class="frame-group f3"><path fill="#f1d492" d="M15 0h8v1h-8zM12 1h4v1h-4zM22 1h3v1h-3zM10 2h3v1h-3zM24 2h3v1h-3zM8 3h3v1h-3zM26 3h3v1h-3zM8 4h1v1h-1zM28 4h2v1h-2zM6 5h2v1h-2zM29 5h2v1h-2zM5 6h2v1h-2zM30 6h2v1h-2zM4 7h2v1h-2zM31 7h2v1h-2zM4 8h1v2h-1zM32 8h2v1h-2zM3 9h1v2h-1zM33 9h1v2h-1zM2 11h1v4h-1zM34 11h1v3h-1zM35 13h1v4h-1zM1 14h1v3h-1zM0 16h1v13h-1zM36 16h1v13h-1zM1 28h1v3h-1zM35 28h1v4h-1zM2 30h1v4h-1zM34 31h1v3h-1zM3 34h1v2h-1zM33 34h1v3h-1zM4 35h1v3h-1zM5 37h1v2h-1zM34 37h2v1h-2zM6 38h2v1h-2zM7 39h1v1h-1zM26 41h3v1h-3zM24 42h3v1h-3zM29 42h1v2h-1zM23 43h2v1h-2z"/>
                        <path fill="#3b302a" d="M11 11h3v1h-3zM10 12h1v3h-1zM14 12h1v1h-1zM9 14h1v7h-1zM11 14h8v1h-8zM6 15h1v1h-1zM11 15h1v1h-1zM13 15h8v3h-8zM7 16h1v1h-1zM12 16h1v1h-1zM21 16h1v7h-1zM23 16h2v1h-2zM8 17h1v1h-1zM11 17h1v1h-1zM23 17h1v1h-1zM25 17h1v3h-1zM6 18h1v2h-1zM10 18h1v6h-1zM12 18h5v1h-5zM18 18h3v6h-3zM22 18h1v4h-1zM24 18h1v2h-1zM26 18h1v1h-1zM5 19h1v3h-1zM7 19h1v9h-1zM14 19h2v2h-2zM17 19h1v5h-1zM16 20h1v3h-1zM4 21h1v6h-1zM8 21h1v9h-1zM15 21h1v1h-1zM6 22h1v10h-1zM5 23h1v7h-1zM22 23h1v1h-1zM11 24h1v2h-1zM18 24h2v2h-2zM21 24h1v1h-1zM12 26h1v1h-1zM19 26h1v1h-1z"/>
                        <path fill="#261f1b" d="M8 15h1v2h-1zM10 15h1v3h-1zM12 15h1v1h-1zM11 16h1v1h-1zM25 16h1v1h-1zM6 17h2v1h-2zM12 17h1v1h-1zM22 17h1v1h-1zM26 17h1v1h-1zM7 18h1v1h-1zM11 18h1v2h-1zM23 18h1v18h-1zM12 19h2v1h-2zM26 19h1v3h-1zM24 20h2v4h-2zM22 22h1v1h-1zM21 23h1v1h-1zM9 24h1v2h-1zM20 24h1v2h-1zM22 24h1v11h-1zM25 24h2v1h-2zM21 25h1v1h-1zM21 28h1v6h-1zM20 29h1v4h-1zM18 30h2v1h-2zM8 31h5v1h-5zM19 31h1v1h-1zM8 32h4v1h-4zM8 33h3v2h-3zM8 35h2v1h-2zM8 36h1v5h-1zM9 37h1v2h-1zM23 37h1v5h-1zM22 38h1v3h-1z"/>
                        <path fill="#635143" d="M24 17h1v1h-1zM8 18h1v3h-1zM17 18h1v1h-1zM16 19h1v1h-1zM6 20h1v2h-1zM5 22h1v1h-1z"/>
                        <path fill="#f5d2bc" d="M11 20h3v4h-3zM9 21h1v3h-1zM14 21h1v3h-1zM15 22h1v2h-1zM16 23h1v1h-1zM10 24h1v7h-1zM12 24h1v2h-1zM13 25h1v6h-1zM17 25h1v6h-1zM11 26h1v5h-1zM18 26h1v4h-1zM20 26h2v2h-2zM12 27h1v4h-1zM19 27h1v3h-1zM7 28h1v2h-1zM20 28h1v1h-1zM9 29h1v2h-1zM14 29h3v2h-3zM8 30h1v1h-1zM23 44h2v1h-2zM10 45h2v1h-2zM24 45h2v1h-2zM10 46h1v2h-1z"/>
                        <path fill="#372e27" d="M13 24h5v1h-5zM14 25h3v1h-3z"/>
                        <path fill="#7a5335" d="M9 26h1v1h-1zM15 26h2v1h-2z"/>
                        <path fill="#fbe8d7" d="M14 26h1v3h-1z"/>
                        <path fill="#a37042" d="M9 27h1v2h-1zM15 27h2v2h-2z"/>
                        <path fill="#d59f87" d="M13 31h4v1h-4zM9 39h1v2h-1zM20 39h2v2h-2zM21 41h1v1h-1zM22 42h1v2h-1zM23 45h1v1h-1zM11 46h1v3h-1z"/>
                        <path fill="#d0c0b1" d="M17 31h2v1h-2zM12 32h5v1h-5zM11 33h3v1h-3zM11 34h2v1h-2zM10 35h2v2h-2zM9 36h1v1h-1zM18 36h1v4h-1zM23 36h1v1h-1zM10 37h1v3h-1zM22 37h1v1h-1zM19 39h1v1h-1z"/>
                        <path fill="#fafaf8" d="M17 32h3v4h-3zM14 33h3v7h-3zM20 33h1v6h-1zM13 34h1v6h-1zM21 34h1v5h-1zM12 35h1v5h-1zM22 35h1v2h-1zM17 36h1v4h-1zM19 36h1v3h-1zM11 37h1v3h-1z"/>
                        <path fill="#1b1f28" d="M10 40h10v1h-10zM6 41h1v2h-1zM13 41h1v3h-1zM18 41h3v1h-3zM5 42h1v1h-1zM7 42h2v1h-2zM12 42h1v7h-1zM19 42h3v1h-3zM8 43h4v1h-4zM14 43h5v1h-5zM10 44h2v1h-2zM22 44h1v4h-1zM9 45h1v4h-1zM4 46h1v2h-1zM13 46h1v3h-1zM5 47h4v1h-4zM14 47h8v2h-8zM6 48h3v1h-3z"/>
                        <path fill="#2b3141" d="M7 41h6v1h-6zM14 41h2v2h-2zM17 41h1v2h-1zM9 42h3v1h-3zM16 42h1v1h-1zM18 42h1v1h-1zM4 43h4v3h-4zM19 43h3v4h-3zM8 44h2v1h-2zM13 44h6v2h-6zM8 45h1v2h-1zM5 46h3v1h-3zM14 46h5v1h-5z"/>
                        <path fill="#2a3040" d="M16 41h1v1h-1z"/>
                        <path fill="#d49e87" d="M10 48h1v1h-1z"/></g>
                    <g class="frame-group f4"><path fill="#f1d492" d="M15 0h8v1h-8zM12 1h4v1h-4zM22 1h3v1h-3zM10 2h3v1h-3zM24 2h3v1h-3zM8 3h3v1h-3zM26 3h3v1h-3zM8 4h1v1h-1zM28 4h2v1h-2zM6 5h2v1h-2zM29 5h2v1h-2zM5 6h2v1h-2zM30 6h2v1h-2zM4 7h2v1h-2zM31 7h2v1h-2zM4 8h1v2h-1zM32 8h2v1h-2zM3 9h1v2h-1zM33 9h1v2h-1zM2 11h1v4h-1zM34 11h1v3h-1zM35 13h1v4h-1zM1 14h1v3h-1zM0 16h1v13h-1zM36 16h1v13h-1zM1 28h1v3h-1zM35 28h1v4h-1zM2 30h1v4h-1zM34 31h1v3h-1zM3 34h1v2h-1zM33 34h1v3h-1zM4 35h1v3h-1zM5 37h1v2h-1zM34 37h2v1h-2zM6 38h2v1h-2zM7 39h1v1h-1zM26 41h3v1h-3zM24 42h3v1h-3zM29 42h1v2h-1zM23 43h2v1h-2z"/>
                        <path fill="#3b302a" d="M11 11h3v1h-3zM10 12h1v3h-1zM14 12h1v1h-1zM9 14h1v7h-1zM11 14h8v1h-8zM6 15h1v1h-1zM11 15h1v1h-1zM13 15h8v3h-8zM7 16h1v1h-1zM12 16h1v1h-1zM21 16h1v7h-1zM23 16h2v1h-2zM8 17h1v1h-1zM11 17h1v1h-1zM23 17h1v1h-1zM25 17h1v3h-1zM6 18h1v2h-1zM10 18h1v6h-1zM12 18h5v1h-5zM18 18h3v6h-3zM22 18h1v4h-1zM24 18h1v2h-1zM26 18h1v1h-1zM5 19h1v3h-1zM7 19h1v9h-1zM14 19h2v2h-2zM17 19h1v5h-1zM16 20h1v3h-1zM4 21h1v6h-1zM8 21h1v9h-1zM15 21h1v1h-1zM6 22h1v10h-1zM5 23h1v7h-1zM22 23h1v1h-1zM11 24h1v2h-1zM18 24h2v2h-2zM21 24h1v1h-1zM12 26h1v1h-1zM19 26h1v1h-1z"/>
                        <path fill="#261f1b" d="M8 15h1v2h-1zM10 15h1v3h-1zM12 15h1v1h-1zM11 16h1v1h-1zM25 16h1v1h-1zM6 17h2v1h-2zM12 17h1v1h-1zM22 17h1v1h-1zM26 17h1v1h-1zM7 18h1v1h-1zM11 18h1v2h-1zM23 18h1v18h-1zM12 19h2v1h-2zM26 19h1v3h-1zM24 20h2v4h-2zM22 22h1v1h-1zM21 23h1v1h-1zM9 24h1v2h-1zM20 24h1v2h-1zM22 24h1v11h-1zM25 24h2v1h-2zM21 25h1v1h-1zM21 28h1v6h-1zM20 29h1v4h-1zM18 30h2v1h-2zM8 31h5v1h-5zM19 31h1v1h-1zM8 32h4v1h-4zM8 33h3v2h-3zM8 35h2v1h-2zM8 36h1v5h-1zM9 37h1v2h-1zM23 37h1v5h-1zM22 38h1v3h-1z"/>
                        <path fill="#635143" d="M24 17h1v1h-1zM8 18h1v3h-1zM17 18h1v1h-1zM16 19h1v1h-1zM6 20h1v2h-1zM5 22h1v1h-1z"/>
                        <path fill="#f5d2bc" d="M11 20h3v4h-3zM9 21h1v3h-1zM14 21h1v3h-1zM15 22h1v2h-1zM16 23h1v1h-1zM10 24h1v7h-1zM12 24h1v2h-1zM13 25h1v6h-1zM17 25h1v6h-1zM11 26h1v5h-1zM18 26h1v4h-1zM20 26h2v2h-2zM12 27h1v4h-1zM19 27h1v3h-1zM7 28h1v2h-1zM20 28h1v1h-1zM9 29h1v2h-1zM14 29h3v2h-3zM8 30h1v1h-1zM23 44h2v1h-2zM10 45h2v1h-2zM24 45h2v1h-2zM10 46h1v2h-1z"/>
                        <path fill="#372e27" d="M13 24h5v1h-5zM14 25h3v1h-3z"/>
                        <path fill="#7a5335" d="M9 26h1v1h-1zM15 26h2v1h-2z"/>
                        <path fill="#fbe8d7" d="M14 26h1v3h-1z"/>
                        <path fill="#a37042" d="M9 27h1v2h-1zM15 27h2v2h-2z"/>
                        <path fill="#d59f87" d="M13 31h4v1h-4zM9 39h1v2h-1zM20 39h2v2h-2zM21 41h1v1h-1zM22 42h1v2h-1zM23 45h1v1h-1zM11 46h1v3h-1z"/>
                        <path fill="#d0c0b1" d="M17 31h2v1h-2zM12 32h5v1h-5zM11 33h2v1h-2zM11 34h1v2h-1zM10 35h1v5h-1zM9 36h1v1h-1zM18 36h1v4h-1zM23 36h1v1h-1zM22 37h1v1h-1zM19 39h1v1h-1z"/>
                        <path fill="#fafaf8" d="M17 32h3v4h-3zM13 33h4v7h-4zM20 33h1v6h-1zM12 34h1v6h-1zM21 34h1v5h-1zM22 35h1v2h-1zM11 36h1v4h-1zM17 36h1v4h-1zM19 36h1v3h-1z"/>
                        <path fill="#1b1f28" d="M10 40h10v1h-10zM6 41h1v2h-1zM13 41h1v3h-1zM18 41h3v1h-3zM5 42h1v1h-1zM7 42h2v1h-2zM12 42h1v7h-1zM19 42h3v1h-3zM8 43h4v1h-4zM14 43h5v1h-5zM10 44h2v1h-2zM22 44h1v4h-1zM9 45h1v4h-1zM4 46h1v2h-1zM13 46h1v3h-1zM5 47h4v1h-4zM14 47h8v2h-8zM6 48h3v1h-3z"/>
                        <path fill="#2b3141" d="M7 41h6v1h-6zM14 41h2v2h-2zM17 41h1v2h-1zM9 42h3v1h-3zM16 42h1v1h-1zM18 42h1v1h-1zM4 43h4v3h-4zM19 43h3v4h-3zM8 44h2v1h-2zM13 44h6v2h-6zM8 45h1v2h-1zM5 46h3v1h-3zM14 46h5v1h-5z"/>
                        <path fill="#2a3040" d="M16 41h1v1h-1z"/>
                        <path fill="#d49e87" d="M10 48h1v1h-1z"/></g>
                </svg>
            `,
            // æ»‘é¼ ç§»ä¸Šå»æ™‚çš„å››å½±æ ¼ (Hover)
            pixelHover: `
                <svg viewBox="0 0 37 55" xmlns="http://www.w3.org/2000/svg" shape-rendering="crispEdges">
                    <g class="frame-group f1"><path fill="#f1d492" d="M15 0h8v1h-8zM12 1h4v1h-4zM22 1h3v1h-3zM10 2h3v1h-3zM24 2h3v1h-3zM8 3h3v1h-3zM26 3h3v1h-3zM8 4h1v1h-1zM28 4h2v1h-2zM6 5h2v1h-2zM29 5h2v1h-2zM5 6h2v1h-2zM30 6h2v1h-2zM4 7h2v1h-2zM31 7h2v1h-2zM4 8h1v2h-1zM32 8h2v1h-2zM3 9h1v2h-1zM33 9h1v2h-1zM2 11h1v4h-1zM34 11h1v3h-1zM35 13h1v4h-1zM1 14h1v3h-1zM0 16h1v13h-1zM36 16h1v13h-1zM1 28h1v3h-1zM35 28h1v4h-1zM2 30h1v4h-1zM34 31h1v3h-1zM3 34h1v2h-1zM33 34h1v3h-1zM4 35h1v3h-1zM5 37h1v2h-1zM34 37h2v1h-2zM6 38h1v1h-1zM26 41h3v1h-3zM24 42h3v1h-3zM29 42h1v2h-1zM22 43h3v1h-3zM20 44h2v1h-2z"/>
                        <path fill="#3b302a" d="M11 7h3v1h-3zM10 8h1v3h-1zM14 8h1v1h-1zM9 10h1v7h-1zM11 10h8v1h-8zM6 11h1v1h-1zM11 11h1v1h-1zM13 11h8v3h-8zM7 12h1v1h-1zM12 12h1v1h-1zM21 12h1v7h-1zM23 12h2v1h-2zM8 13h1v1h-1zM11 13h1v1h-1zM23 13h1v1h-1zM25 13h1v3h-1zM6 14h1v2h-1zM10 14h1v6h-1zM12 14h5v1h-5zM18 14h3v6h-3zM22 14h1v4h-1zM24 14h1v2h-1zM26 14h1v1h-1zM5 15h1v3h-1zM7 15h1v9h-1zM14 15h2v2h-2zM17 15h1v5h-1zM16 16h1v3h-1zM4 17h1v6h-1zM8 17h1v9h-1zM15 17h1v1h-1zM6 18h1v10h-1zM5 19h1v7h-1zM22 19h1v1h-1zM11 20h1v2h-1zM18 20h2v2h-2zM21 20h1v1h-1zM12 22h1v1h-1zM19 22h1v1h-1z"/>
                        <path fill="#261f1b" d="M8 11h1v2h-1zM10 11h1v3h-1zM12 11h1v1h-1zM11 12h1v1h-1zM25 12h1v1h-1zM6 13h2v1h-2zM12 13h1v1h-1zM22 13h1v1h-1zM26 13h1v1h-1zM7 14h1v1h-1zM11 14h1v2h-1zM23 14h1v24h-1zM12 15h2v1h-2zM26 15h1v3h-1zM24 16h2v4h-2zM22 18h1v1h-1zM21 19h1v1h-1zM9 20h1v2h-1zM20 20h1v2h-1zM22 20h1v17h-1zM25 20h2v1h-2zM21 21h1v1h-1zM21 24h1v8h-1zM20 25h1v6h-1zM18 26h2v3h-2zM8 27h5v1h-5zM17 27h1v1h-1zM8 28h3v1h-3zM8 29h2v1h-2zM19 29h1v1h-1zM8 30h1v2h-1zM21 34h1v5h-1zM20 35h1v2h-1z"/>
                        <path fill="#635143" d="M24 13h1v1h-1zM8 14h1v3h-1zM17 14h1v1h-1zM16 15h1v1h-1zM6 16h1v2h-1zM5 18h1v1h-1z"/>
                        <path fill="#f5d2bc" d="M11 16h3v4h-3zM9 17h1v3h-1zM14 17h1v3h-1zM15 18h1v2h-1zM16 19h1v1h-1zM10 20h1v7h-1zM12 20h1v2h-1zM13 21h1v6h-1zM17 21h1v6h-1zM11 22h1v5h-1zM18 22h1v4h-1zM20 22h2v2h-2zM12 23h1v4h-1zM19 23h1v3h-1zM7 24h1v2h-1zM20 24h1v1h-1zM9 25h1v2h-1zM14 25h3v2h-3zM8 26h1v1h-1zM16 27h1v1h-1zM18 37h3v4h-3zM21 40h1v4h-1zM19 41h2v2h-2zM22 41h1v2h-1zM20 43h1v1h-1zM15 53h5v2h-5z"/>
                        <path fill="#372e27" d="M13 20h5v1h-5zM14 21h3v1h-3z"/>
                        <path fill="#7a5335" d="M9 22h1v1h-1zM15 22h2v1h-2z"/>
                        <path fill="#fbe8d7" d="M14 22h1v3h-1z"/>
                        <path fill="#a37042" d="M9 23h1v2h-1zM15 23h2v2h-2z"/>
                        <path fill="#d59f87" d="M13 27h3v1h-3zM7 36h1v3h-1zM18 36h2v1h-2zM6 39h1v4h-1zM8 52h5v2h-5zM15 52h5v1h-5zM7 53h1v2h-1zM8 54h4v1h-4z"/>
                        <path fill="#d0c0b1" d="M11 28h1v2h-1zM10 29h1v3h-1zM9 30h1v4h-1zM16 31h1v6h-1zM8 32h1v5h-1zM7 33h1v2h-1zM21 33h1v1h-1zM20 34h1v1h-1zM10 35h4v1h-4zM17 36h1v1h-1z"/>
                        <path fill="#fafaf8" d="M12 28h6v3h-6zM18 29h1v7h-1zM11 30h1v5h-1zM19 30h1v6h-1zM12 31h4v4h-4zM17 31h1v5h-1zM20 31h1v3h-1zM10 32h1v3h-1zM21 32h1v1h-1zM9 34h1v2h-1zM14 35h2v1h-2z"/>
                        <path fill="#1b1f28" d="M9 36h7v2h-7zM8 37h1v2h-1zM16 37h2v2h-2zM9 38h1v14h-1zM12 38h1v2h-1zM7 39h1v3h-1zM17 39h1v3h-1zM13 40h1v4h-1zM18 41h1v4h-1zM6 43h1v3h-1zM19 43h1v2h-1zM7 44h2v1h-2zM10 44h1v8h-1zM14 44h4v1h-4zM8 45h1v7h-1zM20 45h1v3h-1zM5 46h1v5h-1zM11 48h1v4h-1zM21 48h1v3h-1zM7 49h1v3h-1zM12 50h1v2h-1zM20 51h1v1h-1z"/>
                        <path fill="#2b3141" d="M10 38h2v6h-2zM13 38h3v2h-3zM8 39h1v5h-1zM16 39h1v5h-1zM12 40h1v10h-1zM14 40h2v4h-2zM7 42h1v2h-1zM17 42h1v2h-1zM11 44h1v4h-1zM13 44h1v8h-1zM7 45h1v4h-1zM14 45h6v7h-6zM6 46h1v6h-1zM20 48h1v3h-1z"/></g>
                    <g class="frame-group f2"><path fill="#f1d492" d="M15 0h8v1h-8zM12 1h4v1h-4zM22 1h3v1h-3zM10 2h3v1h-3zM24 2h3v1h-3zM8 3h3v1h-3zM26 3h3v1h-3zM8 4h1v1h-1zM28 4h2v1h-2zM6 5h2v1h-2zM29 5h2v1h-2zM5 6h2v1h-2zM30 6h2v1h-2zM4 7h2v1h-2zM31 7h2v1h-2zM4 8h1v2h-1zM32 8h2v1h-2zM3 9h1v2h-1zM33 9h1v2h-1zM2 11h1v4h-1zM34 11h1v3h-1zM35 13h1v4h-1zM1 14h1v3h-1zM0 16h1v13h-1zM36 16h1v13h-1zM1 28h1v3h-1zM35 28h1v4h-1zM2 30h1v4h-1zM34 31h1v3h-1zM3 34h1v2h-1zM33 34h1v3h-1zM4 35h1v3h-1zM5 37h1v2h-1zM34 37h2v1h-2zM6 38h1v1h-1zM26 41h3v1h-3zM24 42h3v1h-3zM29 42h1v2h-1zM22 43h3v1h-3zM20 44h2v1h-2z"/>
                        <path fill="#3b302a" d="M11 7h3v1h-3zM10 8h1v3h-1zM14 8h1v1h-1zM9 10h1v7h-1zM11 10h8v1h-8zM6 11h1v1h-1zM11 11h1v1h-1zM13 11h8v3h-8zM7 12h1v1h-1zM12 12h1v1h-1zM21 12h1v7h-1zM23 12h2v1h-2zM8 13h1v1h-1zM11 13h1v1h-1zM23 13h1v1h-1zM25 13h1v3h-1zM6 14h1v2h-1zM10 14h1v6h-1zM12 14h5v1h-5zM18 14h3v6h-3zM22 14h1v4h-1zM24 14h1v2h-1zM26 14h1v1h-1zM5 15h1v3h-1zM7 15h1v9h-1zM14 15h2v2h-2zM17 15h1v5h-1zM16 16h1v3h-1zM4 17h1v6h-1zM8 17h1v9h-1zM15 17h1v1h-1zM6 18h1v10h-1zM5 19h1v7h-1zM22 19h1v1h-1zM11 20h1v2h-1zM18 20h2v2h-2zM21 20h1v1h-1zM12 22h1v1h-1zM19 22h1v1h-1z"/>
                        <path fill="#261f1b" d="M8 11h1v2h-1zM10 11h1v3h-1zM12 11h1v1h-1zM11 12h1v1h-1zM25 12h1v1h-1zM6 13h2v1h-2zM12 13h1v1h-1zM22 13h1v1h-1zM26 13h1v1h-1zM7 14h1v1h-1zM11 14h1v2h-1zM23 14h1v24h-1zM12 15h2v1h-2zM26 15h1v3h-1zM24 16h2v4h-2zM22 18h1v1h-1zM21 19h1v1h-1zM9 20h1v2h-1zM20 20h1v2h-1zM22 20h1v17h-1zM25 20h2v1h-2zM21 21h1v1h-1zM21 24h1v8h-1zM20 25h1v6h-1zM18 26h2v3h-2zM8 27h5v1h-5zM17 27h1v1h-1zM8 28h3v1h-3zM8 29h2v1h-2zM19 29h1v1h-1zM8 30h1v2h-1zM21 34h1v5h-1zM20 35h1v2h-1z"/>
                        <path fill="#635143" d="M24 13h1v1h-1zM8 14h1v3h-1zM17 14h1v1h-1zM16 15h1v1h-1zM6 16h1v2h-1zM5 18h1v1h-1z"/>
                        <path fill="#f5d2bc" d="M11 16h3v4h-3zM9 17h1v3h-1zM14 17h1v3h-1zM15 18h1v2h-1zM16 19h1v1h-1zM10 20h1v7h-1zM12 20h1v2h-1zM13 21h1v6h-1zM17 21h1v6h-1zM11 22h1v5h-1zM18 22h1v4h-1zM20 22h2v2h-2zM12 23h1v4h-1zM19 23h1v3h-1zM7 24h1v2h-1zM20 24h1v1h-1zM9 25h1v2h-1zM14 25h3v2h-3zM8 26h1v1h-1zM16 27h1v1h-1zM18 37h3v4h-3zM21 40h1v4h-1zM19 41h2v2h-2zM22 41h1v2h-1zM20 43h1v1h-1zM15 53h5v2h-5z"/>
                        <path fill="#372e27" d="M13 20h5v1h-5zM14 21h3v1h-3z"/>
                        <path fill="#7a5335" d="M9 22h1v1h-1zM15 22h2v1h-2z"/>
                        <path fill="#fbe8d7" d="M14 22h1v3h-1z"/>
                        <path fill="#a37042" d="M9 23h1v2h-1zM15 23h2v2h-2z"/>
                        <path fill="#d59f87" d="M13 27h3v1h-3zM7 36h1v3h-1zM18 36h2v1h-2zM6 39h1v4h-1zM8 52h5v2h-5zM15 52h5v1h-5zM7 53h1v2h-1zM8 54h4v1h-4z"/>
                        <path fill="#d0c0b1" d="M11 28h1v1h-1zM10 29h1v2h-1zM9 30h1v4h-1zM16 31h1v6h-1zM8 32h1v5h-1zM7 33h1v2h-1zM21 33h1v1h-1zM20 34h1v1h-1zM10 35h4v1h-4zM17 36h1v1h-1z"/>
                        <path fill="#fafaf8" d="M12 28h6v3h-6zM11 29h1v6h-1zM18 29h1v7h-1zM19 30h1v6h-1zM10 31h1v4h-1zM12 31h4v4h-4zM17 31h1v5h-1zM20 31h1v3h-1zM21 32h1v1h-1zM9 34h1v2h-1zM14 35h2v1h-2z"/>
                        <path fill="#1b1f28" d="M9 36h7v2h-7zM8 37h1v2h-1zM16 37h2v2h-2zM9 38h1v14h-1zM12 38h1v2h-1zM7 39h1v3h-1zM17 39h1v3h-1zM13 40h1v4h-1zM18 41h1v4h-1zM6 43h1v3h-1zM19 43h1v2h-1zM7 44h2v1h-2zM10 44h1v8h-1zM14 44h4v1h-4zM8 45h1v7h-1zM20 45h1v3h-1zM5 46h1v5h-1zM11 48h1v4h-1zM21 48h1v3h-1zM7 49h1v3h-1zM12 50h1v2h-1zM20 51h1v1h-1z"/>
                        <path fill="#2b3141" d="M10 38h2v6h-2zM13 38h3v2h-3zM8 39h1v5h-1zM16 39h1v5h-1zM12 40h1v10h-1zM14 40h2v4h-2zM7 42h1v2h-1zM17 42h1v2h-1zM11 44h1v4h-1zM13 44h1v8h-1zM7 45h1v4h-1zM14 45h6v7h-6zM6 46h1v6h-1zM20 48h1v3h-1z"/></g>
                    <g class="frame-group f3"><path fill="#f1d492" d="M15 0h8v1h-8zM12 1h4v1h-4zM22 1h3v1h-3zM10 2h3v1h-3zM24 2h3v1h-3zM8 3h3v1h-3zM26 3h3v1h-3zM8 4h1v1h-1zM28 4h2v1h-2zM6 5h2v1h-2zM29 5h2v1h-2zM5 6h2v1h-2zM30 6h2v1h-2zM4 7h2v1h-2zM31 7h2v1h-2zM4 8h1v2h-1zM32 8h2v1h-2zM3 9h1v2h-1zM33 9h1v2h-1zM2 11h1v4h-1zM34 11h1v3h-1zM35 13h1v4h-1zM1 14h1v3h-1zM0 16h1v13h-1zM36 16h1v13h-1zM1 28h1v3h-1zM35 28h1v4h-1zM2 30h1v4h-1zM34 31h1v3h-1zM3 34h1v2h-1zM33 34h1v3h-1zM4 35h1v3h-1zM5 37h1v2h-1zM34 37h2v1h-2zM6 38h1v1h-1zM26 41h3v1h-3zM24 42h3v1h-3zM29 42h1v2h-1zM22 43h3v1h-3zM20 44h2v1h-2z"/>
                        <path fill="#3b302a" d="M11 6h3v1h-3zM10 7h1v3h-1zM14 7h1v1h-1zM9 9h1v7h-1zM11 9h8v1h-8zM6 10h1v1h-1zM11 10h1v1h-1zM13 10h8v3h-8zM7 11h1v1h-1zM12 11h1v1h-1zM21 11h1v7h-1zM23 11h2v1h-2zM8 12h1v1h-1zM11 12h1v1h-1zM23 12h1v1h-1zM25 12h1v3h-1zM6 13h1v2h-1zM10 13h1v6h-1zM12 13h5v1h-5zM18 13h3v6h-3zM22 13h1v4h-1zM24 13h1v2h-1zM26 13h1v1h-1zM5 14h1v3h-1zM7 14h1v9h-1zM14 14h2v2h-2zM17 14h1v5h-1zM16 15h1v3h-1zM4 16h1v6h-1zM8 16h1v9h-1zM15 16h1v1h-1zM6 17h1v10h-1zM5 18h1v7h-1zM22 18h1v1h-1zM11 19h1v2h-1zM18 19h2v2h-2zM21 19h1v1h-1zM12 21h1v1h-1zM19 21h1v1h-1z"/>
                        <path fill="#261f1b" d="M8 10h1v2h-1zM10 10h1v3h-1zM12 10h1v1h-1zM11 11h1v1h-1zM25 11h1v1h-1zM6 12h2v1h-2zM12 12h1v1h-1zM22 12h1v1h-1zM26 12h1v1h-1zM7 13h1v1h-1zM11 13h1v2h-1zM23 13h1v24h-1zM12 14h2v1h-2zM26 14h1v3h-1zM24 15h2v4h-2zM22 17h1v1h-1zM21 18h1v1h-1zM9 19h1v2h-1zM20 19h1v2h-1zM22 19h1v17h-1zM25 19h2v1h-2zM21 20h1v1h-1zM21 23h1v8h-1zM20 24h1v6h-1zM18 25h2v3h-2zM8 26h5v1h-5zM17 26h1v1h-1zM8 27h3v1h-3zM8 28h2v1h-2zM19 28h1v1h-1zM8 29h1v2h-1zM21 33h1v5h-1zM20 34h1v3h-1z"/>
                        <path fill="#635143" d="M24 12h1v1h-1zM8 13h1v3h-1zM17 13h1v1h-1zM16 14h1v1h-1zM6 15h1v2h-1zM5 17h1v1h-1z"/>
                        <path fill="#f5d2bc" d="M11 15h3v4h-3zM9 16h1v3h-1zM14 16h1v3h-1zM15 17h1v2h-1zM16 18h1v1h-1zM10 19h1v7h-1zM12 19h1v2h-1zM13 20h1v6h-1zM17 20h1v6h-1zM11 21h1v5h-1zM18 21h1v4h-1zM20 21h2v2h-2zM12 22h1v4h-1zM19 22h1v3h-1zM7 23h1v2h-1zM20 23h1v1h-1zM9 24h1v2h-1zM14 24h3v2h-3zM8 25h1v1h-1zM16 26h1v1h-1zM18 36h2v5h-2zM20 37h1v7h-1zM21 40h1v4h-1zM19 41h1v2h-1zM22 41h1v2h-1zM15 53h5v2h-5z"/>
                        <path fill="#372e27" d="M13 19h5v1h-5zM14 20h3v1h-3z"/>
                        <path fill="#7a5335" d="M9 21h1v1h-1zM15 21h2v1h-2z"/>
                        <path fill="#fbe8d7" d="M14 21h1v3h-1z"/>
                        <path fill="#a37042" d="M9 22h1v2h-1zM15 22h2v2h-2z"/>
                        <path fill="#d59f87" d="M13 26h3v1h-3zM18 35h2v1h-2zM7 36h1v3h-1zM6 39h1v4h-1zM8 52h5v2h-5zM15 52h5v1h-5zM7 53h1v2h-1zM8 54h4v1h-4z"/>
                        <path fill="#d0c0b1" d="M11 27h1v2h-1zM10 28h1v3h-1zM9 29h1v4h-1zM8 31h1v5h-1zM16 31h1v5h-1zM7 32h1v2h-1zM21 32h1v1h-1zM20 33h1v1h-1zM10 35h4v1h-4zM17 35h1v1h-1z"/>
                        <path fill="#fafaf8" d="M12 27h6v4h-6zM18 28h1v7h-1zM11 29h1v6h-1zM19 29h1v6h-1zM20 30h1v3h-1zM10 31h1v4h-1zM12 31h4v4h-4zM17 31h1v4h-1zM21 31h1v1h-1zM9 33h1v3h-1zM14 35h2v1h-2z"/>
                        <path fill="#1b1f28" d="M8 36h10v2h-10zM8 38h2v1h-2zM12 38h1v2h-1zM16 38h2v1h-2zM7 39h1v3h-1zM9 39h1v13h-1zM17 39h1v3h-1zM13 40h1v4h-1zM18 41h1v4h-1zM6 43h1v3h-1zM19 43h1v2h-1zM7 44h2v1h-2zM10 44h1v8h-1zM14 44h4v1h-4zM8 45h1v7h-1zM20 45h1v3h-1zM5 46h1v5h-1zM11 48h1v4h-1zM21 48h1v3h-1zM7 49h1v3h-1zM12 50h1v2h-1zM20 51h1v1h-1z"/>
                        <path fill="#2b3141" d="M10 38h2v6h-2zM13 38h3v2h-3zM8 39h1v5h-1zM16 39h1v5h-1zM12 40h1v10h-1zM14 40h2v4h-2zM7 42h1v2h-1zM17 42h1v2h-1zM11 44h1v4h-1zM13 44h1v8h-1zM7 45h1v4h-1zM14 45h6v7h-6zM6 46h1v6h-1zM20 48h1v3h-1z"/></g>
                    <g class="frame-group f4"><path fill="#f1d492" d="M15 0h8v1h-8zM12 1h4v1h-4zM22 1h3v1h-3zM10 2h3v1h-3zM24 2h3v1h-3zM8 3h3v1h-3zM26 3h3v1h-3zM8 4h1v1h-1zM28 4h2v1h-2zM6 5h2v1h-2zM29 5h2v1h-2zM5 6h2v1h-2zM30 6h2v1h-2zM4 7h2v1h-2zM31 7h2v1h-2zM4 8h1v2h-1zM32 8h2v1h-2zM3 9h1v2h-1zM33 9h1v2h-1zM2 11h1v4h-1zM34 11h1v3h-1zM35 13h1v4h-1zM1 14h1v3h-1zM0 16h1v13h-1zM36 16h1v13h-1zM1 28h1v3h-1zM35 28h1v4h-1zM2 30h1v4h-1zM34 31h1v3h-1zM3 34h1v2h-1zM33 34h1v3h-1zM4 35h1v3h-1zM5 37h1v2h-1zM34 37h2v1h-2zM6 38h1v1h-1zM26 41h3v1h-3zM24 42h3v1h-3zM29 42h1v2h-1zM22 43h3v1h-3zM20 44h2v1h-2z"/>
                        <path fill="#3b302a" d="M11 6h3v1h-3zM10 7h1v3h-1zM14 7h1v1h-1zM9 9h1v7h-1zM11 9h8v1h-8zM6 10h1v1h-1zM11 10h1v1h-1zM13 10h8v3h-8zM7 11h1v1h-1zM12 11h1v1h-1zM21 11h1v7h-1zM23 11h2v1h-2zM8 12h1v1h-1zM11 12h1v1h-1zM23 12h1v1h-1zM25 12h1v3h-1zM6 13h1v2h-1zM10 13h1v6h-1zM12 13h5v1h-5zM18 13h3v6h-3zM22 13h1v4h-1zM24 13h1v2h-1zM26 13h1v1h-1zM5 14h1v3h-1zM7 14h1v9h-1zM14 14h2v2h-2zM17 14h1v5h-1zM16 15h1v3h-1zM4 16h1v6h-1zM8 16h1v9h-1zM15 16h1v1h-1zM6 17h1v10h-1zM5 18h1v7h-1zM22 18h1v1h-1zM11 19h1v2h-1zM18 19h2v2h-2zM21 19h1v1h-1zM12 21h1v1h-1zM19 21h1v1h-1z"/>
                        <path fill="#261f1b" d="M8 10h1v2h-1zM10 10h1v3h-1zM12 10h1v1h-1zM11 11h1v1h-1zM25 11h1v1h-1zM6 12h2v1h-2zM12 12h1v1h-1zM22 12h1v1h-1zM26 12h1v1h-1zM7 13h1v1h-1zM11 13h1v2h-1zM23 13h1v24h-1zM12 14h2v1h-2zM26 14h1v3h-1zM24 15h2v4h-2zM22 17h1v1h-1zM21 18h1v1h-1zM9 19h1v2h-1zM20 19h1v2h-1zM22 19h1v17h-1zM25 19h2v1h-2zM21 20h1v1h-1zM21 23h1v8h-1zM20 24h1v6h-1zM18 25h2v3h-2zM8 26h5v1h-5zM17 26h1v1h-1zM8 27h3v1h-3zM8 28h2v1h-2zM19 28h1v1h-1zM8 29h1v2h-1zM21 33h1v5h-1zM20 34h1v3h-1z"/>
                        <path fill="#635143" d="M24 12h1v1h-1zM8 13h1v3h-1zM17 13h1v1h-1zM16 14h1v1h-1zM6 15h1v2h-1zM5 17h1v1h-1z"/>
                        <path fill="#f5d2bc" d="M11 15h3v4h-3zM9 16h1v3h-1zM14 16h1v3h-1zM15 17h1v2h-1zM16 18h1v1h-1zM10 19h1v7h-1zM12 19h1v2h-1zM13 20h1v6h-1zM17 20h1v6h-1zM11 21h1v5h-1zM18 21h1v4h-1zM20 21h2v2h-2zM12 22h1v4h-1zM19 22h1v3h-1zM7 23h1v2h-1zM20 23h1v1h-1zM9 24h1v2h-1zM14 24h3v2h-3zM8 25h1v1h-1zM16 26h1v1h-1zM18 36h2v5h-2zM20 37h1v7h-1zM21 40h1v4h-1zM19 41h1v2h-1zM22 41h1v2h-1zM15 53h5v2h-5z"/>
                        <path fill="#372e27" d="M13 19h5v1h-5zM14 20h3v1h-3z"/>
                        <path fill="#7a5335" d="M9 21h1v1h-1zM15 21h2v1h-2z"/>
                        <path fill="#fbe8d7" d="M14 21h1v3h-1z"/>
                        <path fill="#a37042" d="M9 22h1v2h-1zM15 22h2v2h-2z"/>
                        <path fill="#d59f87" d="M13 26h3v1h-3zM18 35h2v1h-2zM7 36h1v3h-1zM6 39h1v4h-1zM8 52h5v2h-5zM15 52h5v1h-5zM7 53h1v2h-1zM8 54h4v1h-4z"/>
                        <path fill="#d0c0b1" d="M11 27h1v1h-1zM10 28h1v2h-1zM9 29h1v3h-1zM8 31h1v5h-1zM16 31h1v5h-1zM7 32h1v2h-1zM21 32h1v1h-1zM20 33h1v1h-1zM10 35h4v1h-4zM17 35h1v1h-1z"/>
                        <path fill="#fafaf8" d="M12 27h6v4h-6zM11 28h1v7h-1zM18 28h1v7h-1zM19 29h1v6h-1zM10 30h1v5h-1zM20 30h1v3h-1zM12 31h4v4h-4zM17 31h1v4h-1zM21 31h1v1h-1zM9 32h1v4h-1zM14 35h2v1h-2z"/>
                        <path fill="#1b1f28" d="M8 36h10v2h-10zM8 38h2v1h-2zM12 38h1v2h-1zM16 38h2v1h-2zM7 39h1v3h-1zM9 39h1v13h-1zM17 39h1v3h-1zM13 40h1v4h-1zM18 41h1v4h-1zM6 43h1v3h-1zM19 43h1v2h-1zM7 44h2v1h-2zM10 44h1v8h-1zM14 44h4v1h-4zM8 45h1v7h-1zM20 45h1v3h-1zM5 46h1v5h-1zM11 48h1v4h-1zM21 48h1v3h-1zM7 49h1v3h-1zM12 50h1v2h-1zM20 51h1v1h-1z"/>
                        <path fill="#2b3141" d="M10 38h2v6h-2zM13 38h3v2h-3zM8 39h1v5h-1zM16 39h1v5h-1zM12 40h1v10h-1zM14 40h2v4h-2zM7 42h1v2h-1zM17 42h1v2h-1zM11 44h1v4h-1zM13 44h1v8h-1zM7 45h1v4h-1zM14 45h6v7h-6zM6 46h1v6h-1zM20 48h1v3h-1z"/></g>
                    </svg>
                  `,
            textMap: {
                zh: {
                    appTitle: 'Voronoi Plane',
                    modeLayout: 'æ’ç‰ˆ', modeImage: 'åœ–ç‰‡', modeText: 'æ–‡å­—', modeTemplate: 'æ¨¡æ¿',
                    addText: 'æ–‡å­—', copyText: 'è¤‡è£½', importFont: 'åŒ¯å…¥å­—å‹',
                    editContent: 'ç·¨è¼¯å…§å®¹',
                    size: 'å¤§å°', rotate: 'æ—‹è½‰', skewX: 'æ–œ X', skewY: 'æ–œ Y',
                    layerOrder: 'åœ–å±¤é †åº', layerTop: 'ç½®é ‚', layerUp: 'ä¸Šç§»', layerDown: 'ä¸‹ç§»', layerBottom: 'ç½®åº•',
                    fontFamily: 'å­—å‹', colorStyle: 'é¡è‰² & æ¨£å¼', textStroke: 'æ–‡å­—å¤–æ¡†', delText: 'åˆªé™¤æ–‡å­—',
                    vertical: 'ç›´æ’', layerBg: 'èƒŒæ™¯', layerFg: 'å‰æ™¯',
                    nodeControl: 'ç¯€é»æ§åˆ¶', nodeCount: 'æ§åˆ¶é»æ•¸é‡', addPoint: 'å¢é»', removePoint: 'æ¸›é»',
                    layoutStyle: 'æ’ç‰ˆæ¨£å¼', gridGap: 'æ ¼å­é–“è·', radius: 'å€’åœ“è§’',
                    imgBorder: 'åœ–ç‰‡å¤–æ¡†', borderAlpha: 'å¤–æ¡†é€æ˜åº¦', showGuides: 'é¡¯ç¤ºè¼”åŠ©ç·š', seamlessMode: 'ç„¡ç¸«æ¨¡å¼ (åƒ…æ‹¼åˆåœ–)',
                    imgInfo: 'åœ–ç‰‡è³‡è¨Š', fileSize: 'æª”æ¡ˆå¤§å°', fileName: 'æª”æ¡ˆåç¨±', lastMod: 'ä¿®æ”¹æ—¥æœŸ', dimensions: 'åŸåœ–å°ºå¯¸', missing: 'éºå¤±', emptyCell: 'ç©ºæ ¼å­',
                    swapInstruction: 'è«‹é»æ“Šç›®æ¨™åœ–ç‰‡é€²è¡Œäº¤æ›\n(ç›®å‰å·²é¸å®šä¾†æº)',
                    imgTools: 'åœ–ç‰‡å·¥å…·', selected: 'å·²é¸å–', unselected: 'æœªé¸å–',
                    replaceImg: 'æ›´æ›/è®€å–åœ–ç‰‡', swapPos: 'äº¤æ›ä½ç½® (é»ä¸‹ä¸€å€‹)', scale: 'ç¸®æ”¾',
                    resetCenter: 'å›åˆ°æ­£ä¸­ (Reset)', flip: 'ç¿»è½‰', delete: 'åˆªé™¤', delCell: 'åˆªé™¤æ ¼å­',
                    cancelSwap: 'å–æ¶ˆäº¤æ›',
                    globalSettings: 'å…¨åŸŸè¨­å®š', canvasSize: 'ç•«å¸ƒå°ºå¯¸', width: 'å¯¬', height: 'é«˜',
                    bgSettings: 'èƒŒæ™¯è¨­å®š', bgSolid: 'å–®è‰²', bgGrad: 'æ¼¸å±¤', color: 'é¡è‰²', opacity: 'é€æ˜åº¦', angle: 'è§’åº¦',
                    margin: 'å¤–æ¡†ç•™ç™½', horizontal: 'æ°´å¹³', vertical: 'å‚ç›´',
                    addImages: 'åŠ å…¥åœ–ç‰‡', addEmpty: 'åŠ å…¥ç©ºæ ¼', resetLayout: 'é‡æ–°æ’åˆ—', clearAll: 'å…¨éƒ¨æ¸…ç©º', relink: 'æ‰¹æ¬¡è£œæª”',
                    saveProj: 'å„²å­˜å°ˆæ¡ˆ', loadProj: 'è®€å–å°ˆæ¡ˆ', download: 'ä¸‹è¼‰å¤§åœ–',
                    confirm: 'ç¢ºå®š', cancel: 'å–æ¶ˆ',
                    msgResetTitle: 'é‡ç½®ä½ˆå±€', msgResetBody: 'ç¢ºå®šè¦é‡æ–°æ’åˆ—åœ–ç‰‡å—ï¼Ÿ\né€™å°‡ç§»é™¤æ‰€æœ‰è‡ªè¨‚æ§åˆ¶é»ä¸¦é‡ç½®åœ–ç‰‡ä½ç½®ã€‚',
                    msgClearTitle: 'å…¨éƒ¨æ¸…ç©º', msgClearBody: 'ç¢ºå®šè¦åˆªé™¤æ‰€æœ‰åœ–ç‰‡å’Œæ–‡å­—å—ï¼Ÿ\næ­¤å‹•ä½œç„¡æ³•å¾©åŸã€‚',
                    info: 'è¨Šæ¯', error: 'éŒ¯èª¤',connectNode: 'é€£æ¥/å»¶ä¼¸ç¯€é» (é»æ“Šç•«é¢)',
                    tplSettings: 'æ¨¡æ¿åƒæ•¸', tplSpacing: 'é–“è·å¤§å° (Size)', tplRoundness: 'éš”é›¢å¼·åº¦ (Count)', tplJitter: 'éš¨æ©ŸæŠ–å‹• (Chaos)',
                    tplSelect: 'é¸æ“‡ç‰ˆå‹ (è‡ªå‹•å¥—åœ–)', tplFlower: 'æŠ«è–©', tplHoneycomb: 'èŠ±', tplCircle: 'é¸šéµ¡èº',
                    tplFilm: 'åº•ç‰‡', tplMasonry: 'ç¢å½¢', tplPyramid: 'é‡‘å­—å¡”',
                    // æ–°å¢è£œé½Š
                    modeSwitch: 'åˆ‡æ›æ¨¡å¼', gridManage: 'ç®¡ç†æ ¼å­', style: 'æ¨£å¼', stickerSettings: 'è²¼åœ–è¨­å®š', 
                    transformControl: 'è®Šå½¢æ§åˆ¶', addObject: 'æ–°å¢ç‰©ä»¶', fileOps: 'æª”æ¡ˆæ“ä½œ', uiInfo: 'è¨Šæ¯'
                },
                en: {
                    appTitle: 'Voronoi Plane',
                    modeLayout: 'Layout', modeImage: 'Image', modeText: 'Text', modeTemplate: 'Template',
                    addText: 'Text', copyText: 'Duplicate', importFont: 'Font',
                    editContent: 'Edit Content',
                    size: 'Size', rotate: 'Rot', skewX: 'Sk X', skewY: 'Sk Y',
                    layerOrder: 'Layer Order', layerTop: 'Top', layerUp: 'Up', layerDown: 'Down', layerBottom: 'Btm',
                    fontFamily: 'Font Family', colorStyle: 'Color & Style', textStroke: 'Stroke', delText: 'Delete Text',
                    vertical: 'Vert', layerBg: 'Back', layerFg: 'Front',
                    nodeControl: 'Node Control', nodeCount: 'Count', addPoint: 'Add', removePoint: 'Remove',
                    layoutStyle: 'Layout Style', gridGap: 'Gap', radius: 'Radius',
                    imgBorder: 'Image Border', borderAlpha: 'Border Alpha', showGuides: 'Show Guides', seamlessMode: 'Seamless Mode',
                    imgInfo: 'Image Info', fileSize: 'Size', fileName: 'Name', lastMod: 'Modified', dimensions: 'Dim', missing: 'Missing', emptyCell: 'Empty Cell',
                    swapInstruction: 'Click target image to swap\n(Source selected)',
                    imgTools: 'Tools', selected: 'Selected', unselected: 'None',
                    replaceImg: 'Replace / Load', swapPos: 'Swap Position', scale: 'Scale',
                    resetCenter: 'Center', flip: 'Flip', delete: 'Delete', delCell: 'Del Cell',
                    cancelSwap: 'Cancel Swap',
                    globalSettings: 'Global Settings', canvasSize: 'Canvas Size', width: 'W', height: 'H',
                    bgSettings: 'Background', bgSolid: 'Solid', bgGrad: 'Gradient', color: 'Color', opacity: 'Opacity', angle: 'Angle',
                    margin: 'Margin', horizontal: 'Hor', vertical: 'Ver',
                    addImages: 'Add Images', addEmpty: 'Add Empty', resetLayout: 'Reset Layout', clearAll: 'Clear All', relink: 'Relink',
                    saveProj: 'Save Project', loadProj: 'Load Project', download: 'Export PNG',
                    confirm: 'Confirm', cancel: 'Cancel',
                    msgResetTitle: 'Reset Layout', msgResetBody: 'Reset all images and remove custom points?',
                    msgClearTitle: 'Clear All', msgClearBody: 'Remove all images and texts? This cannot be undone.',
                    info: 'Info', error: 'Error',connectNode: 'Connect/Extend Node',
                    tplSettings: 'Template Settings', tplSpacing: 'Gap Size', tplRoundness: 'Buffer Count', tplJitter: 'Chaos',
                    tplSelect: 'Select Preset (Auto-Fill)', tplFlower: 'Pizza', tplHoneycomb: 'Flower', tplCircle: 'Nautilus',
                    tplFilm: 'Film Strip', tplMasonry: 'Fractal', tplPyramid: 'Pyramid',
                    // æ–°å¢è£œé½Š
                    modeSwitch: 'Switch Mode', gridManage: 'Manage Grid', style: 'Style', stickerSettings: 'Sticker Settings', 
                    transformControl: 'Transform', addObject: 'Add New', fileOps: 'File Operations', uiInfo: 'Info'
                }
            },

            outWidth: 1920, outHeight: 1080,
            mode: 'layout', 
            viewZoom: 1,
            panX: 0, panY: 0,
            isPanning: false,
            isRightScaling: false,
            
            tplPadding: 200, tplSpacing: 2, tplJitter: 0, tplCount: 12, tplStrength: 1,
            tplCenterX: 960, tplCenterY: 540, lastTemplateType: 'flower',
            
            bgType: 'solid', bgColor1: '#111111', bgAlpha1: 1, bgColor2: '#333333', bgAlpha2: 1, bgAngle: 135,
            gap: 10, cornerRadius: 0, marginTop: 0, marginBottom: 0, marginLeft: 0, marginRight: 0,
            showBorders: true, mergeInternal: false,
            imgBorder: false, imgBorderColor: '#ffffff', imgBorderWidth: 5, imgBorderAlpha: 1,

            sites: [], images: [], texts: [], stickers: [],
            fontOptions: [
                { value: "'Noto Sans TC'", label: "æ€æºé»‘é«” (æ¨™æº–)" }, { value: "'Noto Serif TC'", label: "æ€æºå®‹é«” (è¥¯ç·š)" },
                { value: "'Bangers'", label: "Bangers" }, { value: "'Pacifico'", label: "Pacifico" },
                { value: "'Lobster'", label: "Lobster" }, { value: "'Russo One'", label: "Russo" },
                { value: "'Caveat'", label: "Caveat" }, { value: "'Montserrat'", label: "ç¾ä»£ç„¡è¥¯ç·š" },
                { value: "Arial", label: "Arial (ç³»çµ±)" }
            ],

            selectedImgId: null, selectedImgIds: [], 
            selectedTextId: null, selectedTextIds: [],
            selectedSiteId: null, selectedSiteIds: [], selectedStickerId: null, selectedStickerIds: [],
            editingTextId: null, tempTextContent: '', inputStyle: {},
            
            isSwapping: false, swapSourceId: null,
            delaunay: null, voronoi: null, ctx: null,
            draggedId: null, lastX: 0, lastY: 0,

            showConfirm: false, confirmTitle: '', confirmMsg: '', pendingAction: null, isAlert: false,
            
            history: [], historyIndex: -1, 
            isUndoing: false,
            imageRegistry: {},
            dragStartInfo: null,
            isBoxSelecting: false, boxStart: { x: 0, y: 0 }, boxEnd: { x: 0, y: 0 },
            
            textHandlePos: null, scaleHandlePos: null,

            transformStart: {
                angle: 0, dist: 0, rotation: 0, scale: 1, fontSize: 10, cx: 0, cy: 0
            },
            isUniTransforming: false,
            gridZIndex: 500,

            isBottomCollapsed: false, // æ–°å¢ï¼šæ§åˆ¶å´é‚Šæ¬„åº•éƒ¨å·¥å…·å€æ”¶é—”

            // æ–°å¢è§¸æ§å°ˆç”¨ç‹€æ…‹
            isTouchZooming: false,
            lastPinchDist: 0,
            touchCenter: { x: 0, y: 0 },
            lastTapTime: 0, // æ–°å¢ï¼šç”¨æ–¼ç´€éŒ„ä¸Šæ¬¡è§¸ç¢°æ™‚é–“ï¼Œåˆ¤æ–·é›™æ“Š
            isDrawersOverlapping: false // æ–°å¢ï¼šåµæ¸¬æŠ½å±œæ˜¯å¦é‡ç–Š
        },
        computed: {
            ui() { return this.textMap[this.lang]; },
            selectionBoxStyle() {
                if (!this.isBoxSelecting) return {};
                const x = Math.min(this.boxStart.x, this.boxEnd.x);
                const y = Math.min(this.boxStart.y, this.boxEnd.y);
                const w = Math.abs(this.boxEnd.x - this.boxStart.x);
                const h = Math.abs(this.boxEnd.y - this.boxStart.y);
                return { left: x + 'px', top: y + 'px', width: w + 'px', height: h + 'px' };
            }
        },
        mounted() {
            // ç§»æ¤é‚è¼¯ï¼šç²¾æº–é–å®šè¦–çª—ç¯„åœ
            const fixVH = () => {
                // ä¿®æ­£ iOS ä¸‹ç¶²å€åˆ—æ”¶èµ·æ™‚å¯èƒ½ç”¢ç”Ÿçš„ä½ç§»
                window.scrollTo(0, 0);
                
                // é‡æ–°æŠ“å–ç›®å‰ã€ŒçœŸæ­£ã€çš„å¯è¦–é«˜åº¦
                const vh = window.visualViewport ? window.visualViewport.height : window.innerHeight;
                document.documentElement.style.setProperty('--vh', `${vh}px`);
                
                // å¼·åˆ¶ç•«å¸ƒé‡æ–°é©æ‡‰ä¸€æ¬¡
                if (this.ctx) this.render();
            };
            
            // ç›£è½ visualViewport è®ŠåŒ–ï¼ˆé€™æ˜¯å°æŠ—æ‰‹æ©Ÿéµç›¤æ¨æ“ çš„æœ€ä½³è§£ï¼‰
            if (window.visualViewport) {
                window.visualViewport.addEventListener('resize', fixVH);
                window.visualViewport.addEventListener('scroll', fixVH);
            }
            window.addEventListener('resize', fixVH);
            fixVH();

            // --- ä¿ç•™æ‚¨åŸæœ¬çš„åˆå§‹åŒ–é‚è¼¯ (ç¬¬ä¸€çµ„) ---
            if(window.innerHeight > window.innerWidth) { this.outWidth=1080; this.outHeight=1920; }
            this.tplCenterX = this.outWidth / 2; this.tplCenterY = this.outHeight / 2;
            this.ctx = this.$refs.canvas.getContext('2d');
            this.render();
            setTimeout(() => {
                this.fitView();
                this.saveState(); 
            }, 150);
            window.addEventListener('mouseup', (e) => this.handleEnd(e));

            // --- ä¿ç•™æ‚¨åŸæœ¬çš„åˆå§‹åŒ–é‚è¼¯ (ç¬¬äºŒçµ„ï¼Œå«è¨»è§£) ---
            if(window.innerHeight > window.innerWidth) { this.outWidth=1080; this.outHeight=1920; }
            this.tplCenterX = this.outWidth / 2; this.tplCenterY = this.outHeight / 2;
            this.ctx = this.$refs.canvas.getContext('2d');
            this.render();
            setTimeout(() => {
                this.fitView();
                this.saveState(); // ç¢ºä¿åˆæ¬¡æ¸²æŸ“å¾Œå­˜ä¸‹ç¬¬ä¸€ç­†ç©ºç‹€æ…‹
            }, 150);
            window.addEventListener('mouseup', (e) => this.handleEnd(e));

            // --- å®Œæ•´ä¿ç•™æ‚¨è¦æ±‚çš„å¿«æ·éµåŠŸèƒ½ ---
            window.addEventListener('keydown', (e) => {
                // æ’é™¤æ­£åœ¨è¼¸å…¥æ–‡å­—çš„æƒ…æ³
                if (['INPUT', 'TEXTAREA'].includes(e.target.tagName)) return;

                // A. å¿«æ·éµï¼šUndo / Redo
                if (e.ctrlKey || e.metaKey) {
                    if (e.key === 'z') { e.preventDefault(); if (e.shiftKey) this.redo(); else this.undo(); } 
                    else if (e.key === 'y') { e.preventDefault(); this.redo(); }
                }

                // B. å¿«æ·éµï¼šDelete åˆªé™¤åŠŸèƒ½
                if (e.key === 'Delete') {
                    if (this.mode === 'layout') {
                        // æ’ç‰ˆæ¨¡å¼ï¼šå„ªå…ˆåˆªé™¤é¸ä¸­çš„ç¯€é»ï¼Œè‹¥ç„¡ç¯€é»å‰‡åˆªé™¤é¸ä¸­çš„åœ–ç‰‡æ ¼
                        if (this.selectedSiteIds.length > 0) this.removePoint();
                        else if (this.selectedImgId) this.deleteImg();
                    } else if (this.mode === 'image') {
                        // åœ–ç‰‡æ¨¡å¼ï¼šåˆªé™¤é¸ä¸­çš„åœ–ç‰‡
                        if (this.selectedImgIds.length > 0) this.deleteImg();
                    } else if (this.mode === 'text') {
                        // æ–‡å­—æ¨¡å¼ï¼šåˆªé™¤é¸ä¸­çš„æ–‡å­—æˆ–è²¼åœ–
                        if (this.selectedTextIds.length > 0) this.deleteText();
                        if (this.selectedStickerIds.length > 0) this.deleteSticker();
                    }
                }
            });
        },
        methods: {
            toggleSidebar() {
                this.isSidebarCollapsed = !this.isSidebarCollapsed;
                this.$nextTick(() => {
                    this.render();
                });
            },
            resetTplCenter() { this.tplCenterX = Math.round(this.outWidth / 2); this.tplCenterY = Math.round(this.outHeight / 2); this.updateTemplate(); },
            getNodeColor(s) { if (s.id === this.draggedId) return '#FF4444'; if (this.selectedSiteIds.includes(s.id)) return '#00ffaa'; if (s.imgId === this.selectedImgId) return '#FFD700'; return '#ffffff'; },
            
        saveState() {
                if (this.isUndoing) return;
                
                // 1. ç¢ºä¿ Registry åŒ…å«ç•¶å‰æ‰€æœ‰æœ‰æ•ˆçš„åœ–ç‰‡å¯¦é«”
                const allSourceImages = [...this.images, ...this.stickers];
                allSourceImages.forEach(img => {
                    if (img.obj && !this.imageRegistry[String(img.id)]) {
                        this.imageRegistry[String(img.id)] = { obj: img.obj, srcData: img.srcData || null };
                    }
                });

                // 2. åºåˆ—åŒ–ç•¶å‰å®Œæ•´ç‹€æ…‹ (é—œéµä¿®æ­£ï¼šè²¼åœ–ä¸å†é‡è¤‡å„²å­˜ Base64 æª”æ¡ˆè³‡æ–™)
                const stateObj = {
                    sites: JSON.parse(JSON.stringify(this.sites)),
                    texts: JSON.parse(JSON.stringify(this.texts)),
                    stickers: this.stickers.map(s => ({
                        id: s.id, name: s.name, x: s.x, y: s.y, scale: s.scale, 
                        scaleX: s.scaleX, rotation: s.rotation, alpha: s.alpha, 
                        zIndex: s.zIndex, width: s.width, height: s.height, type: 'sticker'
                    })),
                    images: this.images.map(img => ({
                        id: img.id, name: img.name, size: img.size, 
                        lastModified: img.lastModified, isEmpty: img.isEmpty, 
                        x: img.x, y: img.y, scale: img.scale, 
                        scaleX: img.scaleX, rotation: img.rotation
                    })),
                    canvas: {
                        outWidth: this.outWidth, outHeight: this.outHeight, gap: this.gap,
                        cornerRadius: this.cornerRadius, marginTop: this.marginTop,
                        marginBottom: this.marginBottom, marginLeft: this.marginLeft, marginRight: this.marginRight,
                        bgType: this.bgType, bgColor1: this.bgColor1, bgAlpha1: this.bgAlpha1,
                        bgColor2: this.bgColor2, bgAlpha2: this.bgAlpha2, bgAngle: this.bgAngle
                    }
                };

                const stateStr = JSON.stringify(stateObj);

                // é¿å…å„²å­˜é‡è¤‡çš„ç‹€æ…‹
                if (this.historyIndex >= 0 && this.history[this.historyIndex] === stateStr) return;

                // 3. ç®¡ç†æ­·å²å †ç–Š
                if (this.historyIndex < this.history.length - 1) {
                    this.history = this.history.slice(0, this.historyIndex + 1);
                }
                this.history.push(stateStr);
                if (this.history.length > 30) this.history.shift();
                else this.historyIndex++;
            },

            restoreState(stateStr) {
                if (!stateStr) return;
                this.isUndoing = true; // é–‹é–ï¼šç¦æ­¢é‚„åŸæœŸé–“ç”¢ç”Ÿæ–°ç´€éŒ„
                
                const state = JSON.parse(stateStr);

                // 1. é‚„åŸåŸºæœ¬ç•«å¸ƒè¨­å®š
                if (state.canvas) {
                    Object.assign(this, state.canvas);
                }

                // 2. é‚„åŸåœ–å…ƒé™£åˆ—
                this.sites = state.sites;
                this.texts = state.texts;
                
                // 3. æ ¸å¿ƒï¼šå¼·åˆ¶é‡å»ºåœ–ç‰‡ç‰©ä»¶é—œè¯ (æ’ç‰ˆåœ–ç‰‡)
                this.images = state.images.map(savedImg => {
                    const registryData = this.imageRegistry[String(savedImg.id)];
                    if (registryData) {
                        return { ...savedImg, obj: registryData.obj, srcData: registryData.srcData };
                    }
                    return { ...savedImg, obj: null, srcData: null };
                });

                // 4. æ ¸å¿ƒï¼šå¼·åˆ¶é‡å»ºè²¼åœ–ç‰©ä»¶é—œè¯
                const savedStickers = state.stickers || [];
                this.stickers = savedStickers.map(savedStk => {
                    const registryData = this.imageRegistry[String(savedStk.id)];
                    if (registryData) {
                        return { ...savedStk, obj: registryData.obj, srcData: registryData.srcData };
                    }
                    return { ...savedStk, obj: null, srcData: null };
                });

                // 5. å®‰å…¨æª¢æŸ¥ï¼šé‡ç½®éæ™‚çš„é¸å– ID (é¿å…å¾©åŸå¾Œé¸åˆ°ä¸å­˜åœ¨çš„ ID)
                this.selectedTextId = null; this.selectedTextIds = [];
                this.selectedStickerId = null; this.selectedStickerIds = [];
                this.selectedImgId = null;

                // 4. æ›´æ–°ç•«é¢ä¸¦è§£é–
                this.$nextTick(() => {
                    this.render();
                    setTimeout(() => { this.isUndoing = false; }, 50); // å»¶é²è§£é–ç¢ºä¿äº‹ä»¶éƒ½å·²æ¶ˆåŒ–
                });
            },

            undo() {
                if (this.historyIndex > 0) {
                    this.historyIndex--;
                    this.restoreState(this.history[this.historyIndex]);
                }
            },

            redo() {
                if (this.historyIndex < this.history.length - 1) {
                    this.historyIndex++;
                    this.restoreState(this.history[this.historyIndex]);
                }
            },            
            async saveFileWithPicker(blob, defaultName, ext) {
                try {
                    if (window.showSaveFilePicker) {
                        const handle = await window.showSaveFilePicker({ suggestedName: defaultName, types: [{ description: 'File', accept: { [ext === 'json' ? 'application/json' : 'image/png']: ['.' + ext] }, }], });
                        const writable = await handle.createWritable(); await writable.write(blob); await writable.close();
                    } else {
                        const link = document.createElement('a'); link.href = URL.createObjectURL(blob); link.download = defaultName; link.click();
                    }
                } catch (err) { console.log('Save cancelled'); }
            },
            toggleLang() { this.lang = this.lang === 'zh' ? 'en' : 'zh'; },
            formatSize(bytes) { if(!bytes || isNaN(bytes)) return '-'; if(bytes === 0) return '0 B'; const k = 1024; const sizes = ['B', 'KB', 'MB', 'GB']; const i = Math.floor(Math.log(bytes) / Math.log(k)); return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i]; },
            formatDate(ts) { if(!ts) return '-'; const d = new Date(ts); return `${d.getFullYear()}/${(d.getMonth()+1).toString().padStart(2,'0')}/${d.getDate().toString().padStart(2,'0')} ${d.getHours().toString().padStart(2,'0')}:${d.getMinutes().toString().padStart(2,'0')}`; },
            handleGlobalContextMenu(e) { if (['INPUT', 'TEXTAREA'].includes(e.target.tagName)) return; e.preventDefault(); },
            
            setMode(m) {
                if (m === 'text') this.selectedImgId = null;
                if (this.mode === 'text' && m !== 'text') { this.selectedTextId = null; this.editingTextId = null; }
                
                // åˆ‡æ›è‡³æ’ç‰ˆæ¨¡å¼æ™‚ï¼Œæ¸…ç©ºåœ–ç‰‡æ¨¡å¼çš„é¸å–ç‹€æ…‹
                if (m === 'layout') {
                    this.selectedImgId = null;
                    this.selectedImgIds = [];
                }

                this.selectedSiteId = null; this.selectedSiteIds = []; this.selectedTextIds = [];
                this.mode = m;
                
                // ç§»é™¤å¼·åˆ¶å±•é–‹å´é‚Šæ¬„çš„é‚è¼¯ï¼Œåƒ…ä¿ç•™è¨­å®šå€å¡Šçš„å±•é–‹ç‹€æ…‹
                if (m === 'settings') { this.isGlobalSettingsOpen = true; }
                
                this.cancelSwap(); this.render();
            },
            deselectAll() { 
                if(this.editingTextId) this.finishEdit(); 
                if(this.isSwapping) this.cancelSwap(); 
                this.activeDrawer = null; // è‡ªå‹•æ”¶åˆæŠ½å±œ
                this.selectedImgId = null; 
                this.selectedImgIds = []; 
                this.selectedTextId = null; 
                this.selectedTextIds = []; 
                this.selectedStickerId = null; 
                this.selectedStickerIds = []; 
                this.selectedSiteId = null; 
                this.selectedSiteIds = []; 
                this.render(); 
            },

            updateMultiText(prop, value) { 
                let val = value; if (['x', 'y', 'fontSize', 'rotation', 'skewX', 'skewY', 'zIndex', 'strokeWidth'].includes(prop)) { val = parseFloat(value); if (isNaN(val)) return; }
                this.selectedTextIds.forEach(id => { const t = this.texts.find(text => text.id === id); if (t) t[prop] = val; }); 
                this.render(); this.saveState(); 
            },
            updateMultiSticker(prop, value) {
                let val = value; if (['x', 'y', 'scale', 'rotation', 'alpha', 'zIndex'].includes(prop)) { val = parseFloat(value); if (isNaN(val)) return; }
                this.selectedStickerIds.forEach(id => { const s = this.stickers.find(sticker => sticker.id === id); if (s) s[prop] = val; });
                this.render(); this.saveState();
            },

            fitView() { const container = this.$el.querySelector('.canvas-area'); if (!container) return; const padding = 40; const availableW = container.clientWidth - padding; const availableH = container.clientHeight - padding; const scaleW = availableW / this.outWidth; const scaleH = availableH / this.outHeight; let newZoom = Math.min(scaleW, scaleH); newZoom = Math.min(Math.max(newZoom, 0.1), 5); this.viewZoom = parseFloat(newZoom.toFixed(2)); this.panX = 0; this.panY = 0; },
            resetView() { this.viewZoom = 1; this.panX = 0; this.panY = 0; },
            
            updateVoronoi() {
                if(this.sites.length===0) return;
                const points = this.sites.map(s=>[s.x, s.y]); this.delaunay = d3.Delaunay.from(points);
                this.voronoi = this.delaunay.voronoi([ this.marginLeft, this.marginTop, this.outWidth - this.marginRight, this.outHeight - this.marginBottom ]);
            },
            isEdgeExternal(siteIdx, p1, p2) {
                const mx = (p1[0] + p2[0]) / 2; const my = (p1[1] + p2[1]) / 2;
                const dx = mx - this.sites[siteIdx].x; const dy = my - this.sites[siteIdx].y;
                const len = Math.sqrt(dx*dx + dy*dy) || 1; const offset = 0.1; 
                const px = mx + (dx / len) * offset; const py = my + (dy / len) * offset;
                const neighbor = this.delaunay.find(px, py);
                if(neighbor === -1) return true; if(neighbor === siteIdx) return true;
                return this.sites[neighbor].imgId !== this.sites[siteIdx].imgId;
            },
            arePointsClose(p1, p2) { return Math.abs(p1[0] - p2[0]) < 0.5 && Math.abs(p1[1] - p2[1]) < 0.5; },
            getMergedPolygons(imgId) {
                const idxs = this.sites.map((s,i) => s.imgId === imgId ? i : -1).filter(i => i !== -1);
                if (idxs.length === 0) return [];
                let segments = [];
                idxs.forEach(idx => {
                    const poly = this.voronoi.cellPolygon(idx); if(!poly) return;
                    const len = poly.length - 1; 
                    for (let i = 0; i < len; i++) {
                        const p1 = poly[i]; const p2 = poly[(i + 1) % (len + 1)]; 
                        if (this.isEdgeExternal(idx, p1, p2)) segments.push({ start: p1, end: p2 });
                    }
                });
                if(segments.length === 0) return [];
                const polygons = [];
                while (segments.length > 0) {
                    let currentPoly = []; let currentSeg = segments.pop(); 
                    currentPoly.push(currentSeg.start); let nextPoint = currentSeg.end;
                    let found = true;
                    while (found) {
                        const idx = segments.findIndex(s => this.arePointsClose(s.start, nextPoint));
                        if (idx !== -1) { currentSeg = segments.splice(idx, 1)[0]; currentPoly.push(currentSeg.start); nextPoint = currentSeg.end; } 
                        else { found = false; }
                    }
                    currentPoly.push(currentPoly[0]); polygons.push(currentPoly);
                }
                return polygons;
            },
            drawPath(ctx, polygon, idx, enableMerge) {
                if(!polygon || polygon.length<2) return; const len = polygon.length-1; 
                if (idx === -1) {
                    const p0 = polygon[0], pLast = polygon[len-1]; const startX = (p0[0]+pLast[0])/2, startY = (p0[1]+pLast[1])/2;
                    ctx.moveTo(startX, startY);
                    for(let i=0; i<len; i++) {
                        const pCur = polygon[i]; const pNext = polygon[(i+1)%len]; const pPrev = polygon[(i-1+len)%len];
                        const d1 = Math.hypot(pCur[0]-pPrev[0], pCur[1]-pPrev[1]); const d2 = Math.hypot(pNext[0]-pCur[0], pNext[1]-pCur[1]);
                        const effR = Math.min(this.cornerRadius, d1/2, d2/2); ctx.arcTo(pCur[0], pCur[1], pNext[0], pNext[1], effR);
                    }
                    ctx.closePath(); return;
                }
                const edgeIsExternal = [];
                if (enableMerge) { for(let i=0; i<len; i++) edgeIsExternal[i] = this.isEdgeExternal(idx, polygon[i], polygon[(i+1)%len]); }
                const radii = [];
                for(let i=0; i<len; i++) { if(enableMerge) { const prevExt = edgeIsExternal[(i - 1 + len) % len]; const curExt = edgeIsExternal[i]; if(!prevExt || !curExt) radii[i] = 0; else radii[i] = this.cornerRadius; } else { radii[i] = this.cornerRadius; } }
                const p0 = polygon[0], pLast = polygon[len-1]; const startX = (p0[0]+pLast[0])/2, startY = (p0[1]+pLast[1])/2;
                ctx.moveTo(startX, startY);
                for(let i=0; i<len; i++) {
                    const pCur = polygon[i]; const pNext = polygon[(i+1)%len]; const r = radii[i]; const pPrev = polygon[(i-1+len)%len];
                    const d1 = Math.hypot(pCur[0]-pPrev[0], pCur[1]-pPrev[1]); const d2 = Math.hypot(pNext[0]-pCur[0], pNext[1]-pCur[1]);
                    const effR = Math.min(r, d1/2, d2/2); if(effR < 0.5) ctx.arcTo(pCur[0], pCur[1], pNext[0], pNext[1], 0); else ctx.arcTo(pCur[0], pCur[1], pNext[0], pNext[1], effR);
                }
                ctx.closePath();
            },
            traceExternalOnly(ctx, idx, enableMerge) {
                const poly = this.voronoi.cellPolygon(idx); if(!poly) return;
                if (!enableMerge) { this.drawPath(ctx, poly, idx, false); return; }
                const len = poly.length - 1; const edgeIsExternal = [];
                for(let i=0; i<len; i++) edgeIsExternal[i] = this.isEdgeExternal(idx, poly[i], poly[(i+1)%len]);
                for(let i=0; i<len; i++) { const pCur = poly[i]; const pNext = poly[(i+1)%len]; if(edgeIsExternal[i]) { ctx.moveTo(pCur[0], pCur[1]); ctx.lineTo(pNext[0], pNext[1]); } }
            },
            hexToRgba(hex, alpha) { const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex); return result ? `rgba(${parseInt(result[1], 16)},${parseInt(result[2], 16)},${parseInt(result[3], 16)}, ${alpha})` : `rgba(0,0,0,${alpha})`; },
            getBgFill(ctx, w, h) {
                if (this.bgType === 'solid') { return this.hexToRgba(this.bgColor1, this.bgAlpha1); } else {
                    const rad = (this.bgAngle - 90) * Math.PI / 180; const r = Math.sqrt(w*w + h*h) / 2; const cx = w/2, cy = h/2;
                    const x1 = cx - Math.cos(rad) * r, y1 = cy - Math.sin(rad) * r; const x2 = cx + Math.cos(rad) * r, y2 = cy + Math.sin(rad) * r;
                    const grad = ctx.createLinearGradient(x1, y1, x2, y2); grad.addColorStop(0, this.hexToRgba(this.bgColor1, this.bgAlpha1)); grad.addColorStop(1, this.hexToRgba(this.bgColor2, this.bgAlpha2)); return grad;
                }
            },
            
            // ==========================================
            // æ ¸å¿ƒæ¸²æŸ“ Render (åˆä½µåœ–å±¤ + æ‰‹æŸ„)
            // ==========================================
            // ==========================================
            // æ ¸å¿ƒæ¸²æŸ“ Render (åˆä½µåœ–å±¤ + æ‰‹æŸ„)
            // ==========================================
            render() {
                if(!this.ctx) return;
                const ctx = this.ctx;
                const w = this.outWidth, h = this.outHeight;
                
                ctx.imageSmoothingEnabled = true;
                ctx.imageSmoothingQuality = 'high';

                ctx.clearRect(0,0, w, h);
                
                // 1. åˆå§‹æª¢æŸ¥
                if(this.sites.length===0 && this.texts.length===0 && this.stickers.length===0) {
                    if (this.mode !== 'export') {
                        ctx.save(); ctx.fillStyle='#999'; ctx.font='30px sans-serif'; ctx.textAlign='center';
                        const msg = this.lang === 'zh' ? 'è«‹åŠ å…¥åœ–ç‰‡æˆ–æ–‡å­—' : 'Please add images or text';
                        ctx.fillText(msg, w/2, h/2); ctx.restore();
                    }
                    return;
                }

                this.updateVoronoi();

                // --- A. æœ€åº•å±¤ï¼šèƒŒæ™¯å¡«å…… ---
                ctx.save();
                ctx.fillStyle = this.getBgFill(ctx, w, h);
                ctx.fillRect(0, 0, w, h);
                ctx.restore();

                // --- B. æ··åˆæ’åºæº–å‚™ ---
                const renderQueue = [
                    ...this.texts.map(t => ({ ...t, _ref: t, type: 'text' })),
                    ...this.stickers.map(s => ({ ...s, _ref: s, type: 'sticker' })),
                    { type: 'grid', zIndex: this.gridZIndex } 
                ].sort((a, b) => (a.zIndex || 0) - (b.zIndex || 0));

                // --- C. ä¾åºç¹ªè£½æ¸…å–® ---
                renderQueue.forEach(item => {
                    if (item.type === 'grid') {
                        // === ã€ç¹ªè£½åœ–ç‰‡ç¶²æ ¼å±¤ã€‘ä¿®æ­£ï¼šé‡è¤‡ä½¿ç”¨ç•«å¸ƒé¿å…è¨˜æ†¶é«”æº¢å‡º ===
                        if (!this.offscreenCanvas) {
                            this.offscreenCanvas = document.createElement('canvas');
                        }
                        const tempCanvas = this.offscreenCanvas;
                        if (tempCanvas.width !== w || tempCanvas.height !== h) {
                            tempCanvas.width = w; 
                            tempCanvas.height = h;
                        }
                        const tCtx = tempCanvas.getContext('2d');
                        tCtx.clearRect(0, 0, w, h); // å‹™å¿…æ¸…ç©ºé‡è¤‡ä½¿ç”¨çš„ç•«å¸ƒ
                        tCtx.imageSmoothingEnabled = true;
                        tCtx.imageSmoothingQuality = 'high';

                        const siteCounts = {}; this.sites.forEach(s => { siteCounts[s.imgId] = (siteCounts[s.imgId] || 0) + 1; });
                        
                        // --- C1. ç¹ªè£½åœ–ç‰‡å…§å®¹èˆ‡ã€Œå…§åµŒå¼å¤–æ¡†ã€ ---
                        this.images.forEach(img => {
                            const idxs = this.sites.map((s,i)=>s.imgId===img.id?i:-1).filter(i=>i!==-1); if(idxs.length===0) return;
                            const count = siteCounts[img.id] || 0; 
                            const useSeamless = this.mergeInternal && count > 1;
                            
                            tCtx.save(); 
                            tCtx.beginPath();
                            
                            if (useSeamless) { 
                                const polys = this.getMergedPolygons(img.id); 
                                polys.forEach(poly => { this.drawPath(tCtx, poly, -1, false); }); 
                            } 
                            else { 
                                idxs.forEach(idx => { 
                                    const poly = this.voronoi.cellPolygon(idx); 
                                    if(poly) this.drawPath(tCtx, poly, idx, this.mergeInternal); 
                                }); 
                            }
                            
                            tCtx.clip(); 

                            if (!img.isEmpty) {
                                let cx=0, cy=0; idxs.forEach(i => { cx+=this.sites[i].x; cy+=this.sites[i].y; }); cx /= idxs.length; cy /= idxs.length;
                                tCtx.save();
                                tCtx.translate(cx + img.x, cy + img.y); tCtx.rotate(img.rotation * Math.PI/180); tCtx.scale(img.scale * (img.scaleX||1), img.scale);
                                if(img.obj) { tCtx.drawImage(img.obj, -img.obj.width/2, -img.obj.height/2); } 
                                else { 
                                    tCtx.fillStyle = '#222'; tCtx.fillRect(-150, -60, 300, 120); 
                                    tCtx.fillStyle = '#888'; tCtx.textAlign = 'center'; 
                                    tCtx.font = 'bold 24px sans-serif'; tCtx.fillText(this.lang === 'zh' ? 'åœ–ç‰‡éºå¤±' : 'Missing Image', 0, -10);
                                    tCtx.font = '14px monospace'; tCtx.fillText(img.name || 'Unknown', 0, 20);
                                }
                                tCtx.restore();
                            } else {
                                if (this.mode !== 'export' && (this.showBorders || img.id === this.selectedImgId)) {
                                    tCtx.fillStyle = 'rgba(255, 255, 255, 0.1)'; tCtx.fill();
                                }
                            }

                            if(this.imgBorder && this.imgBorderWidth > 0 && !img.isEmpty) {
                                tCtx.lineWidth = this.imgBorderWidth * 2; 
                                tCtx.strokeStyle = this.hexToRgba(this.imgBorderColor, this.imgBorderAlpha); 
                                tCtx.lineJoin = 'round'; tCtx.lineCap = 'round';
                                tCtx.stroke(); 
                            }
                            
                            tCtx.restore();
                        });

                        if(this.gap > 0) {
                            tCtx.save(); tCtx.globalCompositeOperation = 'destination-out'; tCtx.lineWidth = this.gap; tCtx.lineCap = 'round'; tCtx.lineJoin = 'round'; tCtx.strokeStyle = 'rgba(0,0,0,1)';
                            tCtx.beginPath(); for(let i=0; i<this.sites.length; i++) { const s = this.sites[i]; const enableMerge = this.mergeInternal && (siteCounts[s.imgId] > 1); this.traceExternalOnly(tCtx, i, enableMerge); } tCtx.stroke(); tCtx.restore();
                        }

                        ctx.drawImage(tempCanvas, 0, 0);

                        if (this.mode !== 'export') {
                            const selectedImageIds = new Set(this.selectedImgIds); 
                            if (this.selectedImgId) selectedImageIds.add(this.selectedImgId); 
                            this.selectedSiteIds.forEach(id => { 
                                const s = this.sites.find(site => site.id === id); 
                                if (s) selectedImageIds.add(s.imgId); 
                            });

                            this.images.forEach(img => {
                                const isSel = (this.mode !== 'text' && this.mode !== 'template') && selectedImageIds.has(img.id);
                                if(this.showBorders || isSel) {
                                    const idxs = this.sites.map((s,i)=>s.imgId===img.id?i:-1).filter(i=>i!==-1);
                                    ctx.save(); 
                                    ctx.strokeStyle = isSel ? '#FFD700' : '#888';
                                    ctx.lineWidth = isSel ? 3 : 1;
                                    ctx.setLineDash([]);
                                    ctx.beginPath(); 
                                    idxs.forEach(idx => { this.traceExternalOnly(ctx, idx, false); }); 
                                    ctx.stroke(); 
                                    ctx.restore();
                                }
                            });
                            if(this.mode === 'layout') {
                                ctx.save(); ctx.strokeStyle = 'rgba(255,255,255,0.5)'; ctx.setLineDash([4,4]); ctx.lineWidth = 1;
                                this.images.forEach(img => { const g = this.sites.filter(s=>s.imgId===img.id); if(g.length>1) { ctx.beginPath(); for(let i=0; i<g.length-1; i++) { ctx.moveTo(g[i].x, g[i].y); ctx.lineTo(g[i+1].x, g[i+1].y); } ctx.stroke(); } }); ctx.restore();
                            }
                        }
                    } else {
                        const t = item._ref;
                        if (item.type === 'text' && t.id === this.editingTextId) return;

                        ctx.save();
                        ctx.translate(t.x, t.y); ctx.rotate(t.rotation * Math.PI / 180);
                        
                        if (item.type === 'sticker') {
                            ctx.scale(t.scale * (t.scaleX || 1), t.scale); ctx.globalAlpha = t.alpha; 
                            if (t.obj) {
                                ctx.drawImage(t.obj, -t.width/2, -t.height/2);
                            } else {
                                ctx.fillStyle = '#222'; ctx.fillRect(-t.width/2, -t.height/2, t.width, t.height);
                                ctx.strokeStyle = '#444'; ctx.lineWidth = 1/t.scale; ctx.strokeRect(-t.width/2, -t.height/2, t.width, t.height);
                                ctx.fillStyle = '#888'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
                                ctx.font = `bold ${Math.min(20, t.width/6)}px sans-serif`;
                                ctx.fillText(this.lang === 'zh' ? 'è²¼åœ–éºå¤±' : 'Missing', 0, -t.height/10);
                                ctx.font = `${Math.min(14, t.width/10)}px monospace`;
                                ctx.fillText(t.name || 'Unknown', 0, t.height/10);
                            }
                            if (this.mode === 'text' && this.mode !== 'export' && this.selectedStickerIds.includes(t.id)) {
                                ctx.strokeStyle = (t.id === this.selectedStickerId) ? '#00e5ff' : '#00ffaa'; 
                                ctx.lineWidth = 2 / t.scale; ctx.strokeRect(-t.width/2, -t.height/2, t.width, t.height);
                            }
                        } else if (item.type === 'text') {
                            const radX = (t.skewX || 0) * Math.PI / 180; 
                            const radY = (t.skewY || 0) * Math.PI / 180; 
                            ctx.transform(1, Math.tan(radY), Math.tan(radX), 1, 0, 0);
                            ctx.font = `${t.isItalic ? 'italic ' : ''}${t.isBold ? 'bold ' : ''}${t.fontSize}px ${t.fontFamily}`;
                            ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.fillStyle = t.color;
                            
                            if (t.strokeWidth > 0) {
                                ctx.lineWidth = t.strokeWidth; ctx.strokeStyle = t.strokeColor; ctx.lineJoin = 'round';
                                if (t.isVertical) {
                                    const chars = t.content.split(''); const totalHeight = t.fontSize * chars.length; let currentY = -totalHeight / 2 + t.fontSize / 2;
                                    chars.forEach(char => { ctx.strokeText(char, 0, currentY); currentY += t.fontSize; });
                                } else { ctx.strokeText(t.content, 0, 0); }
                            }
                            if (t.isVertical) {
                                const chars = t.content.split(''); const totalHeight = t.fontSize * chars.length; let currentY = -totalHeight / 2 + t.fontSize / 2;
                                chars.forEach(char => { ctx.fillText(char, 0, currentY); currentY += t.fontSize; });
                            } else { ctx.fillText(t.content, 0, 0); }

                            if (t.isUnderlined) {
                                ctx.save(); ctx.strokeStyle = t.color;
                                ctx.lineWidth = Math.max(1, t.fontSize / 28); ctx.lineCap = 'round';
                                if (t.isVertical) {
                                    const totalHeight = t.fontSize * t.content.length;
                                    const lineX = t.fontSize / 2 + 0.5;
                                    ctx.beginPath(); ctx.moveTo(lineX, -totalHeight / 2); ctx.lineTo(lineX, totalHeight / 2); ctx.stroke();
                                } else {
                                    const metrics = ctx.measureText(t.content);
                                    const lineY = t.fontSize / 2 + 0.5;
                                    ctx.beginPath(); ctx.moveTo(-metrics.width / 2, lineY); ctx.lineTo(metrics.width / 2, lineY); ctx.stroke();
                                }
                                ctx.restore();
                            }
                            if(this.mode === 'text' && this.mode !== 'export' && this.selectedTextIds.includes(t.id)) {
                                const m = this.getTextMetrics(t); 
                                ctx.strokeStyle = (t.id === this.selectedTextId) ? '#00e5ff' : '#00ffaa'; 
                                ctx.lineWidth = 2; ctx.setLineDash([5,5]); ctx.strokeRect(-m.w/2, -m.h/2, m.w, m.h);
                            }
                        }
                        ctx.restore();
                    }
                });

                // --- D. æœ€é ‚å±¤ï¼šæ—‹è½‰æ‰‹æŸ„ ---
                if (this.mode === 'text' && this.mode !== 'export' && !this.editingTextId) {
                    const target = this.selectedStickerId ? this.getSelectedSticker() : (this.selectedTextId ? this.getSelectedText() : null);
                    if (target && target.x !== undefined) {
                        let halfW = 0, halfH = 0;
                        if (this.selectedStickerId) { halfW = (target.width * target.scale) / 2; halfH = (target.height * target.scale) / 2; } 
                        else { const m = this.getTextMetrics(target); halfW = m.w / 2; halfH = m.h / 2; }
                        const padding = 15; const rad = target.rotation * Math.PI / 180;
                        const lx = halfW + padding; const ly = -halfH - padding;
                        this.textHandlePos = { x: target.x + (lx * Math.cos(rad) - ly * Math.sin(rad)), y: target.y + (lx * Math.sin(rad) + ly * Math.cos(rad)) };
                        ctx.save(); ctx.translate(this.textHandlePos.x, this.textHandlePos.y); ctx.rotate(rad);
                        ctx.fillStyle = '#FFD700'; ctx.strokeStyle = '#000'; ctx.lineWidth = 2; ctx.beginPath(); ctx.arc(0, 0, 8, 0, Math.PI*2); ctx.fill(); ctx.stroke();
                        ctx.restore();
                    }
                }
            },

            handleFiles(e) { const files = Array.from(e.target.files).filter(f => f.type.startsWith('image')); this.processBatchUpload(files); e.target.value = ''; },
            handleRelink(e) {
                const files = Array.from(e.target.files); if (files.length === 0) return;
                let matchCount = 0; 
                const fileMap = {}; 
                files.forEach(f => { if(f.type.startsWith('image')) fileMap[f.name] = f; });

                // è™•ç†æ’ç‰ˆåœ–ç‰‡è£œæª”
                this.images.forEach(img => {
                    if (!img.obj && !img.isEmpty && fileMap[img.name]) {
                        const file = fileMap[img.name]; const reader = new FileReader();
                        reader.onload = (evt) => { const imgObj = new Image(); imgObj.onload = () => { img.obj = imgObj; img.srcData = evt.target.result; img.size = file.size; img.lastModified = file.lastModified; this.imageRegistry[String(img.id)] = { obj: imgObj, srcData: evt.target.result }; this.render(); }; imgObj.src = evt.target.result; };
                        reader.readAsDataURL(file); matchCount++;
                    }
                });

                // æ–°å¢ï¼šè™•ç†è²¼åœ–è£œæª”
                this.stickers.forEach(stk => {
                    if (!stk.obj && fileMap[stk.name]) {
                        const file = fileMap[stk.name]; const reader = new FileReader();
                        reader.onload = (evt) => { const imgObj = new Image(); imgObj.onload = () => { stk.obj = imgObj; stk.srcData = evt.target.result; this.imageRegistry[String(stk.id)] = { obj: imgObj, srcData: evt.target.result }; this.render(); }; imgObj.src = evt.target.result; };
                        reader.readAsDataURL(file); matchCount++;
                    }
                });

                e.target.value = ''; 
                if(matchCount > 0) this.showAlert(this.ui.uiTitleInfo || 'è¨Šæ¯', `æˆåŠŸè£œæª” ${matchCount} å€‹ç‰©ä»¶`); 
                else this.showAlert(this.ui.uiTitleInfo || 'è¨Šæ¯', 'æ²’æœ‰æ‰¾åˆ°åŒ¹é…çš„æª”å');
                if(matchCount > 0) this.saveState();
            },
            addEmptyCell() { const id = Date.now() + Math.random(); const rx = this.outWidth * 0.2 + Math.random() * (this.outWidth * 0.6); const ry = this.outHeight * 0.2 + Math.random() * (this.outHeight * 0.6); this.sites.push({id: Date.now(), imgId: id, x: rx, y: ry}); this.images.push({ id, obj: null, srcData: null, name: 'Empty Cell', isEmpty: true, size: 0, lastModified: Date.now(), x:0, y:0, scale:1, rotation:0 }); this.selectedImgId = id; this.render(); this.saveState(); },
            replaceImage(e) {
                const file = e.target.files[0]; if(!file || !this.selectedImgId) return;
                if(file.type.startsWith('image')) {
                    const reader = new FileReader();
                    reader.onload = (evt) => { const imgObj = new Image(); imgObj.onload = () => { const targetImg = this.getSelectedImg(); if(targetImg) { targetImg.obj = imgObj; targetImg.srcData = evt.target.result; targetImg.name = file.name; targetImg.size = file.size; targetImg.lastModified = file.lastModified; targetImg.isEmpty = false; this.imageRegistry[targetImg.id] = { obj: imgObj, srcData: evt.target.result }; this.render(); this.saveState(); } }; imgObj.src = evt.target.result; };
                    reader.readAsDataURL(file);
                } e.target.value = '';
            },
            handleDrop(e) { const files = Array.from(e.dataTransfer.files).filter(f => f.type.startsWith('image')); if (files.length > 0) this.processBatchUpload(files); },
            addImg(imgObj, srcData, meta) { const id = Date.now() + Math.random(); const targetSize = Math.min(this.outWidth, this.outHeight) * 0.75; const s = targetSize / Math.max(imgObj.width, imgObj.height); const rx = this.outWidth * 0.2 + Math.random() * (this.outWidth * 0.6); const ry = this.outHeight * 0.2 + Math.random() * (this.outHeight * 0.6); this.sites.push({id: Date.now(), imgId: id, x: rx, y: ry}); this.imageRegistry[id] = { obj: imgObj, srcData: srcData }; this.images.push({ id, obj: imgObj, srcData, name: meta.name || 'Unknown', size: meta.size, lastModified: meta.lastModified, x:0, y:0, scale:s, rotation:0 }); this.selectedImgId = id; this.render(); this.saveState(); },
            getSelectedImg() { return this.images.find(i=>i.id===this.selectedImgId) || { scale: 1, rotation: 0 }; },
            getPrimarySite() { return this.sites.find(s => s.id === this.selectedSiteId) || {x:0, y:0}; },
            getSelectedSite() { return this.getPrimarySite(); },
            updateMultiCoords(axis, newVal) { if (isNaN(newVal)) return; const fixedVal = Math.round(newVal); this.selectedSiteIds.forEach(id => { const s = this.sites.find(site => site.id === id); if (s) s[axis] = fixedVal; }); this.render(); this.saveState(); },
            activateSwapMode() { if(!this.selectedImgId) return; this.swapSourceId = this.selectedImgId; this.isSwapping = true; },
            cancelSwap() { this.isSwapping = false; this.swapSourceId = null; },
            updateMultiImage(prop, value) {
                const val = parseFloat(value);
                if (isNaN(val)) return;
                this.selectedImgIds.forEach(id => {
                    const img = this.images.find(i => i.id === id);
                    if (img) img[prop] = val;
                });
                this.render();
                this.saveState();
            },

            centerImg() { 
                if (this.selectedImgIds.length === 0) return;
                this.selectedImgIds.forEach(id => {
                    const img = this.images.find(i => i.id === id);
                    if (img) { img.x = 0; img.y = 0; }
                });
                this.render(); 
                this.saveState(); 
            },

            addPoint() { 
                const imgId = this.selectedImgId; 
                if (!imgId) return; 
                let ref = this.sites.find(s => s.id === this.selectedSiteId); 
                if (!ref || ref.imgId !== imgId) { 
                    const mySites = this.sites.filter(s => s.imgId === imgId); 
                    if (mySites.length > 0) ref = mySites[mySites.length - 1]; 
                } 
                if (ref) { 
                    const newId = Date.now() + Math.random(); 
                    this.sites.push({ id: newId, imgId: imgId, x: ref.x + 20, y: ref.y + 20 }); 
                    this.selectedSiteId = newId; 
                    this.selectedSiteIds = [newId]; 
                    this.render(); 
                    this.saveState(); 
                } 
            },

            removePoint() {
                let pointsToRemove = []; 
                if (this.selectedSiteIds.length > 0) pointsToRemove = [...this.selectedSiteIds]; 
                else if (this.selectedSiteId) pointsToRemove = [this.selectedSiteId]; 
                else if (this.selectedImgId) { 
                    const mySites = this.sites.filter(s => s.imgId === this.selectedImgId); 
                    if (mySites.length > 1) pointsToRemove = [mySites[mySites.length - 1].id]; 
                } 
                if (pointsToRemove.length === 0) return;

                const remainingSites = this.sites.filter(s => !pointsToRemove.includes(s.id)); 
                const affectedImgIds = new Set(this.sites.filter(s => pointsToRemove.includes(s.id)).map(s => s.imgId)); 
                let isSafe = true; 
                affectedImgIds.forEach(imgId => { 
                    const count = remainingSites.filter(s => s.imgId === imgId).length; 
                    if (count < 1) isSafe = false; 
                });

                if (!isSafe) { 
                    this.showAlert(this.ui.info, "ç„¡æ³•åˆªé™¤ï¼šæ¯å¼µåœ–ç‰‡è‡³å°‘éœ€è¦ä¿ç•™ä¸€å€‹æ§åˆ¶é»ã€‚"); 
                    return; 
                }
                this.sites = remainingSites; 
                this.selectedSiteId = null; 
                this.selectedSiteIds = []; 
                this.render(); 
                this.saveState();
            },

            resetToSingleNode() { 
                if (this.selectedSiteIds.length === 0) return; 
                let hasChanged = false; 
                [...this.selectedSiteIds].forEach(siteId => { 
                    const site = this.sites.find(s => s.id === siteId); 
                    if (!site) return; 
                    const siblings = this.sites.filter(s => s.imgId === site.imgId); 
                    if (siblings.length <= 1) return; 
                    const originalImg = this.images.find(i => i.id === site.imgId); 
                    if (!originalImg) return; 
                    
                    const newImgId = Date.now() + Math.random(); 
                    const newImg = { ...originalImg, id: newImgId }; 
                    this.images.push(newImg); 
                    if (this.imageRegistry[originalImg.id]) {
                        this.imageRegistry[newImgId] = this.imageRegistry[originalImg.id];
                    }
                    site.imgId = newImgId; 
                    hasChanged = true; 
                }); 
                if (hasChanged) { 
                    const lastSite = this.sites.find(s => s.id === this.selectedSiteIds[this.selectedSiteIds.length-1]); 
                    if (lastSite) this.selectedImgId = lastSite.imgId; 
                    this.render(); 
                    this.saveState(); 
                } 
            },

            deleteImg() {
                const idsToDelete = new Set();
                // å„ªå…ˆè™•ç†æ’ç‰ˆæ¨¡å¼é¸ä¸­çš„ç¯€é»
                if (this.selectedSiteIds.length > 0) {
                    this.selectedSiteIds.forEach(siteId => {
                        const s = this.sites.find(site => site.id === siteId);
                        if (s) idsToDelete.add(s.imgId);
                    });
                } 
                // å¦å‰‡è™•ç†åœ–ç‰‡æ¨¡å¼å¤šé¸é¸ä¸­çš„åœ–ç‰‡
                else if (this.selectedImgIds.length > 0) {
                    this.selectedImgIds.forEach(id => idsToDelete.add(id));
                }

                if (idsToDelete.size === 0) return;

                this.images = this.images.filter(img => !idsToDelete.has(img.id));
                this.sites = this.sites.filter(site => !idsToDelete.has(site.imgId));

                this.selectedImgId = null;
                this.selectedImgIds = [];
                this.selectedSiteId = null;
                this.selectedSiteIds = [];

                this.render();
                this.saveState();
            },

            clearImgContent() { 
                if (this.selectedImgIds.length === 0) return;
                this.selectedImgIds.forEach(id => {
                    const img = this.images.find(i => i.id === id);
                    if (img) {
                        img.obj = null; img.srcData = null; img.isEmpty = true; 
                        img.name = 'Empty Cell'; img.size = 0;
                    }
                });
                this.render(); 
                this.saveState(); 
            },

            flipImg() { 
                if (this.selectedImgIds.length === 0) return;
                this.selectedImgIds.forEach(id => {
                    const img = this.images.find(i => i.id === id);
                    if (img) img.scaleX = (img.scaleX || 1) * -1;
                });
                this.render(); 
                this.saveState(); 
            },

            getSiteCount(id) { 
                return this.sites.filter(s => s.imgId === id).length; 
            },

            processBatchUpload(files) {
                if (files.length === 0) return; 
                
                // æ‰¾å‡ºæ‰€æœ‰éœ€è¦è¢«å¡«è£œçš„å°è±¡ï¼ˆç©ºæ ¼å­æˆ–åœ–ç‰‡éºå¤±çš„æ ¼å­ï¼‰
                let placeholders = this.images.filter(i => i.isEmpty || !i.obj); 
                const tasks = []; 
                let remainingFiles = Array.from(files);

                // 1. å„ªå…ˆè™•ç†ã€Œåç¨±åŒ¹é…ã€ (è£œæª”é‚è¼¯)
                remainingFiles = remainingFiles.filter(file => {
                    const fileNameNoExt = file.name.split('.').slice(0, -1).join('.');
                    const matchIndex = placeholders.findIndex(p => p.name === file.name || p.name === fileNameNoExt);
                    if (matchIndex !== -1) {
                        tasks.push({ file, target: placeholders[matchIndex] });
                        placeholders.splice(matchIndex, 1); // è©²æ ¼å­å·²åˆ†é…ï¼Œç§»é™¤
                        return false; // è©²æª”æ¡ˆå·²åˆ†é…ï¼Œç§»é™¤
                    }
                    return true;
                });

                // 2. å‰©ä¸‹çš„æª”æ¡ˆï¼Œå„ªå…ˆå¡«å…¥ã€Œå‰©ä¸‹çš„ç©ºæ ¼å­/éºå¤±æ ¼å­ã€
                placeholders.sort((a, b) => {
                    if (a.isEmpty === b.isEmpty) return 0;
                    return a.isEmpty ? 1 : -1;
                });

                remainingFiles = remainingFiles.filter(file => {
                    if (placeholders.length > 0) {
                        // ä¾ç…§å‰›æ‰æ’å¥½çš„é †åº (å…ˆéºå¤±æ ¼ï¼Œå¾Œç©ºæ ¼) é€²è¡Œ shift
                        tasks.push({ file, target: placeholders.shift() });
                        return false; 
                    }
                    return true;
                });

                // 3. è‹¥é‚„æœ‰å‰©ä¸‹çš„æª”æ¡ˆï¼Œå‰‡åŸ·è¡Œæ–°å¢æ ¼å­
                remainingFiles.forEach(file => {
                    tasks.push({ file, target: null });
                });

                // çµ±ä¸€åŸ·è¡Œåœ–ç‰‡è™•ç†
                tasks.forEach(task => {
                    const { file, target } = task; 
                    const reader = new FileReader(); 
                    reader.onload = (evt) => { 
                        const imgObj = new Image(); 
                        const meta = { name: file.name, size: file.size, lastModified: file.lastModified }; 
                        imgObj.onload = () => { 
                            if (target) { 
                                // å–ä»£ç¾æœ‰æ ¼å­
                                target.obj = imgObj; 
                                target.srcData = evt.target.result; 
                                target.name = meta.name; 
                                target.size = meta.size; 
                                target.lastModified = meta.lastModified; 
                                target.isEmpty = false; // æ¨™è¨˜ç‚ºéç©º
                                this.imageRegistry[String(target.id)] = { obj: imgObj, srcData: evt.target.result }; 
                            } else { 
                                // å»ºç«‹å…¨æ–°æ ¼å­
                                this.addImg(imgObj, evt.target.result, meta); 
                            } 
                            this.render(); 
                        }; 
                        imgObj.src = evt.target.result; 
                    }; 
                    reader.readAsDataURL(file); 
                });
                setTimeout(() => this.saveState(), 500);
            },
            addText() { 
                const id = Date.now(); 
                const maxZ = this.getMaxZIndex(); 
                this.texts.push({ 
                    id, 
                    content: 'Double Click', 
                    x: this.outWidth/2, 
                    y: this.outHeight/2, 
                    fontSize: 80, 
                    fontFamily: "'Noto Sans TC'", 
                    color: '#ffffff', 
                    rotation: 0, 
                    skewX: 0, 
                    skewY: 0, 
                    isBold: false, 
                    isItalic: false, 
                    isUnderlined: false, // æ–°å¢å±¬æ€§
                    isVertical: false, 
                    strokeColor: '#000000', 
                    strokeWidth: 0, 
                    zIndex: maxZ + 1, 
                    type: 'text' 
                }); 
                this.selectedTextId = id; 
                this.selectedTextIds = [id]; 
                this.selectedStickerId = null; 
                this.render(); 
                this.saveState(); 
            },            
            handleAddSticker(e) {
                const file = e.target.files[0]; if (!file) return;
                const reader = new FileReader();
                reader.onload = (evt) => {
                    const img = new Image();
                    const base64Data = evt.target.result; 
                    img.onload = () => {
                        const id = Date.now();
                        this.stickers.push({
                            id: id, obj: img, srcData: base64Data, 
                            name: file.name, // å‹™å¿…ä¿ç•™æ­¤è¡Œï¼Œè£œæª”ç”¨
                            x: this.outWidth / 2, y: this.outHeight / 2,
                            scale: 1, scaleX: 1, rotation: 0, alpha: 1, width: img.width, height: img.height,
                            zIndex: this.getNextZIndex(),
                            type: 'sticker'
                        });
                        this.selectedStickerId = id; this.selectedStickerIds = [id];
                        this.selectedTextId = null; this.selectedTextIds = [];
                        this.render(); this.saveState();
                    };
                    img.src = evt.target.result;
                };
                reader.readAsDataURL(file); e.target.value = '';
            },
            getSelectedSticker() { return this.stickers.find(s => s.id === this.selectedStickerId) || { x:0, y:0, scale:1, rotation:0, alpha:1 }; },
            deleteSticker() { 
                // æ”¯æ´å¤šé¸åˆªé™¤é‚è¼¯
                const idsToDelete = this.selectedStickerIds.length > 0 ? this.selectedStickerIds : [this.selectedStickerId];
                this.stickers = this.stickers.filter(s => !idsToDelete.includes(s.id)); 
                this.selectedStickerId = null; 
                this.selectedStickerIds = [];
                this.render(); 
                this.saveState(); 
            },
            flipSticker() { 
                const s = this.getSelectedSticker(); 
                if(s.id) { 
                    s.scaleX = (s.scaleX || 1) * -1; 
                    this.render(); 
                    this.saveState(); 
                } 
            },
            changeStickerLayer(action) {
                const s = this.getSelectedSticker(); 
                if(!s.id) return; 
                const idx = this.stickers.findIndex(x => x.id === s.id); 
                if(idx === -1) return; 

                if(action === 'top') {
                    // ç½®é ‚ï¼šç§»åˆ°é™£åˆ—æœ€å¾Œé¢
                    const item = this.stickers.splice(idx, 1)[0];
                    this.stickers.push(item);
                } else if (action === 'bottom') {
                    // ç½®åº•ï¼šç§»åˆ°é™£åˆ—æœ€å‰é¢
                    const item = this.stickers.splice(idx, 1)[0];
                    this.stickers.unshift(item);
                } else if (action === 'up') {
                    // ä¸Šç§»
                    if(idx < this.stickers.length - 1) {
                        const temp = this.stickers[idx];
                        this.stickers[idx] = this.stickers[idx+1];
                        this.stickers[idx+1] = temp;
                    }
                } else if (action === 'down') {
                    // ä¸‹ç§»
                    if(idx > 0) {
                        const temp = this.stickers[idx];
                        this.stickers[idx] = this.stickers[idx-1];
                        this.stickers[idx-1] = temp;
                    }
                }
                this.render(); 
                this.saveState(); 
            },            
            getMaxZIndex() { let max = this.gridZIndex; this.texts.forEach(t => max = Math.max(max, t.zIndex || 0)); this.stickers.forEach(s => max = Math.max(max, s.zIndex || 0)); return max; },
            
            // ==========================================
            // æ··åˆå±¤ç¢°æ’æ¸¬è©¦
            // ==========================================
            hitTestLayer(x, y) {
                const combined = [ 
                    ...this.texts.map(t => ({...t, _ref: t, type: 'text'})), 
                    ...this.stickers.map(s => ({...s, _ref: s, type: 'sticker'})) 
                ].sort((a, b) => (a.zIndex || 0) - (b.zIndex || 0)).reverse();

                for (let item of combined) {
                    const t = item._ref; 
                    const dx = x - t.x; const dy = y - t.y; 
                    const rad = -t.rotation * Math.PI / 180; 
                    const rx = dx * Math.cos(rad) - dy * Math.sin(rad); 
                    const ry = dx * Math.sin(rad) + dy * Math.cos(rad);
                    
                    if (item.type === 'sticker') { 
                        const localX = rx / t.scale; const localY = ry / t.scale; 
                        if (localX >= -t.width/2 && localX <= t.width/2 && localY >= -t.height/2 && localY <= t.height/2) return { type: 'sticker', item: t }; 
                    } else { 
                        const m = this.getTextMetrics(t); 
                        if (Math.abs(rx) < m.w/2 + 10 && Math.abs(ry) < m.h/2 + 10) return { type: 'text', item: t }; 
                    }
                } return null;
            },

            duplicateText() {
                // 1. å¦‚æœé¸ä¸­çš„æ˜¯æ–‡å­—
                if (this.selectedTextId) {
                    const t = this.getSelectedText();
                    if(!t.id) return;
                    
                    // æ·±æ‹·è²æ–‡å­—ç‰©ä»¶
                    const newT = JSON.parse(JSON.stringify(t));
                    newT.id = Date.now();
                    newT.x += 30; // ç¨å¾®éŒ¯ä½ï¼Œè®“ä½¿ç”¨è€…çŸ¥é“è¤‡è£½æˆåŠŸ
                    newT.y += 30;
                    
                    this.texts.push(newT);
                    this.selectedTextId = newT.id;
                    this.selectedTextIds = [newT.id];
                    this.selectedStickerId = null; // ç¢ºä¿äº’æ–¥
                    this.render();
                    this.saveState();
                    return;
                }
                
                // 2. å¦‚æœé¸ä¸­çš„æ˜¯è²¼åœ–
                if (this.selectedStickerId) {
                    const s = this.getSelectedSticker();
                    if(!s.id) return;
                    
                    // è¤‡è£½è²¼åœ–ç‰©ä»¶
                    const newS = {
                        ...s,
                        id: Date.now(),
                        x: s.x + 30,
                        y: s.y + 30
                        // obj (Imageç‰©ä»¶) æ˜¯åƒè€ƒå¼•ç”¨ï¼Œé€™æ²’å•é¡Œï¼Œä¸éœ€è¦é‡æ–°è¼‰å…¥
                    };
                    
                    this.stickers.push(newS);
                    this.selectedStickerId = newS.id;
                    this.selectedTextId = null;
                    this.selectedTextIds = [];
                    this.render();
                    this.saveState();
                }
            },
            changeTextLayer(action) { const t = this.getSelectedText(); if(!t.id) return; const idx = this.texts.findIndex(x => x.id === t.id); if(idx === -1) return; if(action === 'top') { const item = this.texts.splice(idx, 1)[0]; this.texts.push(item); } else if (action === 'bottom') { const item = this.texts.splice(idx, 1)[0]; this.texts.unshift(item); } else if (action === 'up') { if(idx < this.texts.length - 1) { const temp = this.texts[idx]; this.texts[idx] = this.texts[idx+1]; this.texts[idx+1] = temp; } } else if (action === 'down') { if(idx > 0) { const temp = this.texts[idx]; this.texts[idx] = this.texts[idx-1]; this.texts[idx-1] = temp; } } this.render(); this.saveState(); },
            handleFontUpload(e) { const file = e.target.files[0]; if (!file) return; const reader = new FileReader(); reader.onload = (evt) => { try { const fontName = file.name.split('.')[0]; const fontFace = new FontFace(fontName, evt.target.result); fontFace.load().then(loadedFace => { document.fonts.add(loadedFace); this.fontOptions.push({ value: `'${fontName}'`, label: fontName }); if(this.selectedTextIds.length > 0) this.updateMultiText('fontFamily', `'${fontName}'`); }).catch(err => { this.showAlert(this.ui.error, 'å­—å‹è¼‰å…¥å¤±æ•—'); }); } catch (error) { console.error(error); } }; reader.readAsArrayBuffer(file); e.target.value = ''; },
            getSelectedText() { 
                return this.texts.find(t => t.id === this.selectedTextId) || { x:0, y:0, fontSize: 80, rotation: 0, fontFamily: "'Noto Sans TC'", color: '#ffffff', content: '' }; 
            },
            getSelectedSticker() { 
                return this.stickers.find(s => s.id === this.selectedStickerId) || { x:0, y:0, scale: 1, rotation: 0, alpha: 1, zIndex: 0 }; 
            },

            // 2. æ–‡å­—æ¨¡å¼çµ±ä¸€æ›´æ–°å‡½å¼ (è™•ç†åº§æ¨™ã€æ—‹è½‰ç­‰é€šç”¨å±¬æ€§)
             updateTextModeTransform(prop, value) {
                let val = value;
                if (['x', 'y', 'fontSize', 'rotation', 'scale', 'alpha', 'zIndex', 'skewX', 'skewY', 'strokeWidth'].includes(prop)) {
                    val = parseFloat(value);
                    if (isNaN(val)) return; 
                }

                if (prop === 'zIndex') {
                    // æ ¹æ“šç›®å‰ç‰©ä»¶æ˜¯åœ¨å‰æ™¯é‚„èƒŒæ™¯ï¼Œä¾†è§£æè¼¸å…¥çš„æ•¸å­—
                    const master = this.selectedTextId ? this.getSelectedText() : this.getSelectedSticker();
                    const isInBg = master.zIndex < this.gridZIndex;
                    let targetBase = isInBg ? 0 : this.gridZIndex;
                    let targetZ = targetBase + Math.max(1, Math.round(val));

                    const selIds = [...this.selectedTextIds, ...this.selectedStickerIds];
                    const all = [...this.texts, ...this.stickers];
                    const others = all.filter(i => !selIds.includes(i.id));

                    // è¡çªè™•ç†ï¼šå¦‚æœç›®æ¨™å±¤ç´šæœ‰äººä½”ç”¨ï¼Œè©²å€é–“å¾€å¾Œæ“ 
                    if (others.some(i => i.zIndex === targetZ)) {
                        others.forEach(i => { if(i.zIndex >= targetZ) i.zIndex += selIds.length; });
                    }
                    selIds.forEach((id, idx) => {
                        const item = all.find(i => i.id === id);
                        if (item) item.zIndex = targetZ + idx;
                    });
                    this.normalizeZIndices();
                    this.render(); this.saveState(); return;
                }

                // å…¶ä»–å±¬æ€§ (X, Y, Scale...) å®‰å…¨å–æ•´æˆ–ç¯„åœé™åˆ¶
                if (['x', 'y', 'fontSize'].includes(prop)) val = Math.round(val);
                else if (prop === 'alpha') val = Math.max(0, Math.min(1, val));

                this.selectedTextIds.forEach(id => {
                    const t = this.texts.find(text => text.id === id);
                    if (t) t[prop] = val;
                });
                this.selectedStickerIds.forEach(id => {
                    const s = this.stickers.find(sticker => sticker.id === id);
                    if (['x', 'y', 'rotation', 'zIndex', 'alpha', 'scale'].includes(prop) && s) s[prop] = val;
                });
                this.render(); this.saveState();
            },

            deleteText() { this.texts = this.texts.filter(t => !this.selectedTextIds.includes(t.id)); this.selectedTextId = null; this.selectedTextIds = []; this.render(); this.saveState(); },
            getTextMetrics(t) { this.ctx.save(); this.ctx.font = `${t.isItalic?'italic ':''}${t.isBold?'bold ':''}${t.fontSize}px ${t.fontFamily}`; if (t.isVertical) { this.ctx.restore(); return { w: t.fontSize, h: t.fontSize * t.content.length }; } else { const m = this.ctx.measureText(t.content); this.ctx.restore(); return { w: m.width, h: t.fontSize }; } },
            getHandlePos(t) { const { w, h } = this.getTextMetrics(t); const pad = 20; const radSkewX = (t.skewX || 0) * Math.PI / 180; const radSkewY = (t.skewY || 0) * Math.PI / 180; const lx = w / 2 + pad; const ly = h / 2 + pad; const sx = lx + ly * Math.tan(radSkewX); const sy = lx * Math.tan(radSkewY) + ly; const radRot = t.rotation * Math.PI / 180; const finalX = t.x + (sx * Math.cos(radRot) - sy * Math.sin(radRot)); const finalY = t.y + (sx * Math.sin(radRot) + sy * Math.cos(radRot)); return { x: finalX, y: finalY }; },
            handleDblClick(e) { 
                const pos = this.getPointerPos(e);
                const isMulti = e.ctrlKey || e.metaKey || e.shiftKey; // åµæ¸¬å¤šé¸ä¿®é£¾éµ
                
                if (this.mode === 'text') {
                    const hit = this.hitTestLayer(pos.x, pos.y); 
                    if(hit && hit.type === 'text') this.startEdit(hit.item); 
                } 
                else if (this.mode === 'layout') {
                    if (this.delaunay) {
                        const idx = this.delaunay.find(pos.x, pos.y);
                        if (idx !== -1) {
                            const targetImgId = this.sites[idx].imgId;
                            // å–å¾—è©²åœ–ç‰‡æ ¼çš„æ‰€æœ‰ç¯€é» ID
                            const targetNodeIds = this.sites
                                .filter(s => s.imgId === targetImgId)
                                .map(s => s.id);
                            
                            if (isMulti) {
                                // å¤šé¸æ¨¡å¼ï¼šåˆ‡æ›é¸å–ç‹€æ…‹ (Toggle)
                                // åˆ¤æ–·è©²åœ–çš„ç¬¬ä¸€å€‹ç¯€é»æ˜¯å¦å·²åœ¨é¸å–æ¸…å–®ä¸­
                                const isAlreadySelected = this.selectedSiteIds.includes(targetNodeIds[0]);
                                if (isAlreadySelected) {
                                    // ç§»é™¤è©²åœ–æ‰€æœ‰ç¯€é»
                                    this.selectedSiteIds = this.selectedSiteIds.filter(id => !targetNodeIds.includes(id));
                                } else {
                                    // åŠ å…¥è©²åœ–æ‰€æœ‰ç¯€é»
                                    this.selectedSiteIds = [...new Set([...this.selectedSiteIds, ...targetNodeIds])];
                                }
                            } else {
                                // ä¸€èˆ¬æ¨¡å¼ï¼šç›´æ¥æ›¿æ›é¸å–
                                this.selectedSiteIds = targetNodeIds;
                            }
                            
                            // æ›´æ–°ä¸»è¦çš„é¸å– ID èˆ‡åœ–ç‰‡åƒè€ƒ
                            if (this.selectedSiteIds.length > 0) {
                                this.selectedSiteId = this.selectedSiteIds[this.selectedSiteIds.length - 1];
                                const refSite = this.sites.find(s => s.id === this.selectedSiteId);
                                if (refSite) this.selectedImgId = refSite.imgId;
                            } else {
                                this.selectedSiteId = null;
                                this.selectedImgId = null;
                            }
                            this.render();
                        }
                    }
                }
            },  
            // â˜… ç²¾æº–ç·¨è¼¯å®šä½ (ä¿®æ­£ Skew èˆ‡ç¸®æ”¾ä½ç§»å•é¡Œ)
            startEdit(t) {
                this.editingTextId = t.id; 
                this.tempTextContent = t.content; 
                
                // ç²å–æ–‡å­—ç›®å‰çš„å°ºå¯¸
                const { w, h } = this.getTextMetrics(t);
                
                // å–å¾—æ–œåˆ‡è§’åº¦ (Skew)
                const skX = t.skewX || 0;
                const skY = t.skewY || 0;

                this.inputStyle = { 
                    position: 'absolute',
                    left: t.x + 'px', 
                    top: t.y + 'px', 
                    fontSize: t.fontSize + 'px', 
                    fontFamily: t.fontFamily, 
                    color: t.color, 
                    fontWeight: t.isBold ? 'bold' : 'normal', 
                    fontStyle: t.isItalic ? 'italic' : 'normal', 
                    textDecoration: t.isUnderlined ? 'underline' : 'none',
                    // åŒæ­¥æ—‹è½‰ (rotate) èˆ‡ æ–œåˆ‡ (skew)ï¼Œä½¿ç”¨ translate(-50%, -50%) ç¢ºä¿ä¸­å¿ƒå°é½Š
                    transform: `translate(-50%, -50%) rotate(${t.rotation}deg) skew(${skX}deg, ${skY}deg)`, 
                    minWidth: (w + 40) + 'px', 
                    height: (t.fontSize * 1.2) + 'px', 
                    lineHeight: '1.2', 
                    textAlign: 'center',
                    padding: '0', 
                    margin: '0',
                    border: '1px dashed rgba(255, 255, 255, 0.5)',
                    boxSizing: 'content-box', 
                    background: 'transparent',
                    outline: 'none',
                    display: 'block',
                    zIndex: 3000,
                    whiteSpace: 'pre',
                    overflow: 'hidden',
                    resize: 'none'
                };
                
                this.render(); // éš±è— Canvas ä¸Šçš„åŸæ–‡å­—

                this.$nextTick(() => { 
                    const input = this.$refs.floatInput; 
                    if(input) { 
                        input.focus(); 
                        if(t.content === 'Double Click') input.select(); 
                    } 
                });
            },

            finishEdit() { 
                if(!this.editingTextId) return; 
                const t = this.texts.find(x => x.id === this.editingTextId); 
                if(t) {
                    t.content = this.tempTextContent;
                }
                this.editingTextId = null; 
                // ç·¨è¼¯å®Œæˆï¼Œæ¸²æŸ“ç•«å¸ƒï¼ˆæ­¤æ™‚æ–‡å­—æœƒæ¢å¾©æ–œåˆ‡æ•ˆæœå‡ºç¾åœ¨ç•«å¸ƒä¸Šï¼‰
                this.render(); 
                this.saveState(); 
            },
            getPointerPos(e) { const rect = this.$refs.canvas.getBoundingClientRect(); let cx = e.clientX, cy = e.clientY; if(e.touches && e.touches.length) { cx=e.touches[0].clientX; cy=e.touches[0].clientY; } return { x: (cx - rect.left) * (this.outWidth / rect.width), y: (cy - rect.top) * (this.outHeight / rect.height) }; },
            hitTestText(x, y) { return null; },

            // ==========================================
            // Handle Start/Move/End (å« One-Button)
            // ==========================================
            handleStart(e) {
                // 0. å„ªå…ˆåˆ¤æ–·ï¼šå¦‚æœæ­£åœ¨ç·¨è¼¯æ–‡å­—ä¸”é»æ“Šçš„æ˜¯è¼¸å…¥æ¡†ï¼Œå®Œå…¨äº¤çµ¦ç€è¦½å™¨è™•ç†
                if (this.editingTextId && e.target.closest('.float-input')) {
                    return; 
                }

                // 1. åˆ¤æ–·æ˜¯å¦é»æ“Š UI å…ƒç´ 
                const isUI = e.target.closest('.drawer-content, .drawer-main-btn, .zoom-ctrl, .author-link, .sidebar-open-triangle, .sidebar, .btn-sticker-wrapper, .float-input');
                
                // å¦‚æœé»æ“Šçš„æ˜¯æ­£åœ¨é–‹å•Ÿçš„æŠ½å±œé¸å–®å…§éƒ¨ï¼Œç›´æ¥è¿”å›
                if (e.target.closest('.drawer-content')) return;

                // å¦‚æœé»æ“Šçš„æ˜¯ç•«å¸ƒå€åŸŸï¼ˆé UIï¼‰ï¼Œæ”¶åˆæ‡¸æµ®æŠ½å±œ
                if (!isUI) {
                    this.activeDrawer = null;
                    if (this.editingTextId) {
                        // é»æ“Šç•«å¸ƒç©ºç™½è™•æ™‚æ‰çµæŸç·¨è¼¯
                        this.finishEdit();
                    }
                } else if (!e.target.closest('.drawer-main-btn')) {
                    // å¦‚æœé»æ“Šçš„æ˜¯å…¶ä»– UI å…ƒç´ ä½†ä¸æ˜¯æŠ½å±œæŒ‰éˆ•ï¼Œä¸è¦åŸ·è¡Œç•«å¸ƒé‚è¼¯
                    return;
                }

                // 2. å¦‚æœé»æ“Šçš„æ˜¯ UI æ ¹ç¯€é»ï¼Œé˜»æ­¢ç•«å¸ƒè¡Œç‚º
                if (isUI) return;

                // 3. åªæœ‰é»æ“Šç´”ç•«å¸ƒå€åŸŸæ‰åŸ·è¡Œæ””æˆªï¼Œç¢ºä¿ä»‹é¢ä¸è·³å‹•
                if (e.cancelable) e.preventDefault();

                if(this.editingTextId) return;
                
                const isMulti = e.ctrlKey || e.metaKey || e.shiftKey;

                // --- [è¡Œå‹•ç«¯é›™æ“Šåµæ¸¬] ---
                const now = Date.now();
                const tapDelta = now - this.lastTapTime;
                if (e.touches && e.touches.length === 1 && tapDelta > 0 && tapDelta < 300) {
                    this.handleDblClick(e);
                    this.lastTapTime = 0;
                    return;
                }
                this.lastTapTime = now;

                // --- [è™•ç†é›™æŒ‡ç¸®æ”¾èˆ‡ç§»å‹•] ---
                if (e.touches && e.touches.length === 2) {
                    this.isTouchZooming = true;
                    const dx = e.touches[0].clientX - e.touches[1].clientX;
                    const dy = e.touches[0].clientY - e.touches[1].clientY;
                    this.lastPinchDist = Math.sqrt(dx * dx + dy * dy);
                    this.touchCenter = {
                        x: (e.touches[0].clientX + e.touches[1].clientX) / 2,
                        y: (e.touches[0].clientY + e.touches[1].clientY) / 2
                    };
                    return;
                }

                // 1. ä¸­éµå¹³ç§»è™•ç† (æ»‘é¼ )
                if (e.button === 1) { 
                    this.isPanning = true; 
                    this.lastX = e.clientX; 
                    this.lastY = e.clientY; 
                    return; 
                }
                
                // 2. å³éµç¸®æ”¾è™•ç† (æ»‘é¼ )
                if (e.button === 2) { 
                    const pos = this.getPointerPos(e); 
                    if(this.delaunay) { 
                        const idx = this.delaunay.find(pos.x, pos.y); 
                        if(idx!==-1) { 
                            const s=this.sites[idx]; 
                            this.selectedImgId=s.imgId; 
                            this.isRightScaling=true; 
                            this.lastY=e.clientY; 
                            this.render(); 
                        } 
                    } 
                    return; 
                }

                const pos = this.getPointerPos(e); 
                this.lastX = pos.x; this.lastY = pos.y;
                this.mouseDownPos = { x: pos.x, y: pos.y };

                // 3. æ–‡å­—æ¨¡å¼å–®ä¸€æ‰‹æŸ„è®Šå½¢
                if (this.mode === 'text' && this.textHandlePos) {
                    const hitRadius = 30 / this.viewZoom;
                    if (Math.hypot(pos.x - this.textHandlePos.x, pos.y - this.textHandlePos.y) < hitRadius) {
                        this.isUniTransforming = true;
                        const target = this.selectedStickerId ? this.getSelectedSticker() : this.getSelectedText();
                        this.transformStart = { cx: target.x, cy: target.y, angle: Math.atan2(pos.y - target.y, pos.x - target.x), dist: Math.hypot(pos.x - target.x, pos.y - target.y), rotation: target.rotation, scale: target.scale || 1, fontSize: target.fontSize || 20 };
                        return;
                    }
                }

                // 4. æ’ç‰ˆé€£ç·š/å»¶ä¼¸æ¨¡å¼
                if (this.mode === 'layout' && this.isConnecting && this.selectedImgId) {
                    let clickedSite = null; if (this.delaunay) { const idx = this.delaunay.find(pos.x, pos.y); if(idx !== -1) { const s = this.sites[idx]; if (Math.hypot(s.x - pos.x, s.y - pos.y) < 25) clickedSite = s; } }
                    if (clickedSite) { if (clickedSite.imgId !== this.selectedImgId) { clickedSite.imgId = this.selectedImgId; this.render(); this.saveState(); } } 
                    else { const newId = Date.now(); this.sites.push({ id: newId, imgId: this.selectedImgId, x: pos.x, y: pos.y }); this.selectedSiteId = newId; this.selectedSiteIds = [newId]; this.render(); this.saveState(); }
                    return;
                }
                
                if (this.mode === 'text') {
                    const hit = this.hitTestLayer(pos.x, pos.y);
                    this.lastPotentialHit = hit; 
                    const hasSelection = this.selectedTextIds.length > 0 || this.selectedStickerIds.length > 0;
                    
                    if (e.shiftKey && hasSelection) {
                        const items = [];
                        this.selectedTextIds.forEach(id => { const t = this.texts.find(x => x.id === id); if(t) items.push({id: t.id, type: 'text', startX: t.x, startY: t.y}); });
                        this.selectedStickerIds.forEach(id => { const s = this.stickers.find(x => x.id === id); if(s) items.push({id: s.id, type: 'sticker', startX: s.x, startY: s.y}); });
                        this.dragStartInfo = { mouseX: pos.x, mouseY: pos.y, items: items };
                        this.draggedId = hit ? hit.item.id : 'batch-move';
                        this.render(); return;
                    }

                    if (hit) {
                        if (e.ctrlKey || e.metaKey) {
                            if (hit.type === 'sticker') {
                                if (this.selectedStickerIds.includes(hit.item.id)) this.selectedStickerIds = this.selectedStickerIds.filter(id => id !== hit.item.id);
                                else this.selectedStickerIds.push(hit.item.id);
                                this.selectedStickerId = this.selectedStickerIds.length > 0 ? this.selectedStickerIds[this.selectedStickerIds.length-1] : null;
                            } else {
                                if (this.selectedTextIds.includes(hit.item.id)) this.selectedTextIds = this.selectedTextIds.filter(id => id !== hit.item.id);
                                else this.selectedTextIds.push(hit.item.id);
                                this.selectedTextId = this.selectedTextIds.length > 0 ? this.selectedTextIds[this.selectedTextIds.length-1] : null;
                            }
                            this.draggedId = null;
                            this.dragStartInfo = null;
                        } else {
                            this.draggedId = hit.item.id;
                            if (!e.shiftKey) {
                                if (hit.type === 'sticker') {
                                    if (!this.selectedStickerIds.includes(hit.item.id)) { this.selectedStickerIds = [hit.item.id]; this.selectedTextIds = []; this.selectedTextId = null; }
                                    this.selectedStickerId = hit.item.id;
                                } else {
                                    if (!this.selectedTextIds.includes(hit.item.id)) { this.selectedTextIds = [hit.item.id]; this.selectedStickerIds = []; this.selectedStickerId = null; }
                                    this.selectedTextId = hit.item.id;
                                }
                            }
                            const items = [];
                            this.selectedTextIds.forEach(id => { const t = this.texts.find(x => x.id === id); if(t) items.push({id: t.id, type: 'text', startX: t.x, startY: t.y}); });
                            this.selectedStickerIds.forEach(id => { const s = this.stickers.find(x => x.id === id); if(s) items.push({id: s.id, type: 'sticker', startX: s.x, startY: s.y}); });
                            this.dragStartInfo = { mouseX: pos.x, mouseY: pos.y, items: items };
                        }
                        this.render(); return;
                    }

                    if (!isMulti) { 
                        this.deselectAll(); 
                        this.isBoxSelecting = true; 
                        this.boxStart = { x: pos.x, y: pos.y }; this.boxEnd = { x: pos.x, y: pos.y }; 
                    } 
                    this.render(); return;
                }
                
                if (this.delaunay) {
                    const idx = this.delaunay.find(pos.x, pos.y);
                    if(idx !== -1) {
                        const s = this.sites[idx];
                        if(this.isSwapping) { 
                            if(this.swapSourceId && this.swapSourceId !== s.imgId) { 
                                const imgA = this.images.find(i=>i.id===this.swapSourceId); 
                                const imgB = this.images.find(i=>i.id===s.imgId); 
                                if(imgA && imgB) { 
                                    const tempA = { obj: imgA.obj, srcData: imgA.srcData, name: imgA.name, size: imgA.size, lastModified: imgA.lastModified, isEmpty: imgA.isEmpty };
                                    imgA.obj = imgB.obj; imgA.srcData = imgB.srcData; imgA.name = imgB.name; imgA.size = imgB.size; imgA.lastModified = imgB.lastModified; imgA.isEmpty = imgB.isEmpty;
                                    imgB.obj = tempA.obj; imgB.srcData = tempA.srcData; imgB.name = tempA.name; imgB.size = tempA.size; imgB.lastModified = tempA.lastModified; imgB.isEmpty = tempA.isEmpty;
                                    this.imageRegistry[String(imgA.id)] = { obj: imgA.obj, srcData: imgA.srcData };
                                    this.imageRegistry[String(imgB.id)] = { obj: imgB.obj, srcData: imgB.srcData };
                                    this.cancelSwap(); this.render(); this.saveState(); 
                                } 
                            } else { 
                                this.cancelSwap(); this.render(); 
                            } 
                            return; 
                        }

                        const hitRadius = 25 / this.viewZoom;
                        const isNode = Math.hypot(pos.x - s.x, pos.y - s.y) < hitRadius;
                        this.lastPotentialSite = isNode ? s : null;

                        if (this.mode === 'layout') {
                            if (isNode) {
                                if (e.shiftKey && this.selectedSiteIds.includes(s.id)) {
                                    this.draggedId = s.id;
                                    const items = this.selectedSiteIds.map(id => { const st = this.sites.find(site => site.id === id); return { id: st.id, type: 'site', startX: st.x, startY: st.y }; });
                                    this.dragStartInfo = { mouseX: pos.x, mouseY: pos.y, items: items };
                                } else if (e.ctrlKey || e.metaKey) {
                                    this.draggedId = null; this.dragStartInfo = null;
                                    if (this.selectedSiteIds.includes(s.id)) this.selectedSiteIds = this.selectedSiteIds.filter(id => id !== s.id);
                                    else this.selectedSiteIds.push(s.id);
                                    this.selectedSiteId = this.selectedSiteIds.length > 0 ? this.selectedSiteIds[this.selectedSiteIds.length-1] : null;
                                } else if (!e.shiftKey) {
                                    this.draggedId = s.id; this.selectedImgId = s.imgId;
                                    if (!this.selectedSiteIds.includes(s.id)) this.selectedSiteIds = [s.id];
                                    this.selectedSiteId = s.id;
                                    const startItems = this.selectedSiteIds.map(id => { const site = this.sites.find(st => st.id === id); return { id: site.id, type: 'site', startX: site.x, startY: site.y }; }); 
                                    this.dragStartInfo = { mouseX: pos.x, mouseY: pos.y, items: startItems };
                                }
                                this.render(); return;
                            }
                        } else if (this.mode === 'image') {
                            this.lastPotentialImgId = s.imgId;
                            const isAlreadySelected = this.selectedImgIds.includes(s.imgId);

                            if (!isMulti) {
                                if (!isAlreadySelected) {
                                    this.selectedImgId = s.imgId;
                                    this.selectedImgIds = [s.imgId];
                                } else {
                                    this.selectedImgId = s.imgId;
                                }
                            } else if (e.ctrlKey || e.metaKey) {
                                if (isAlreadySelected) { this.selectedImgIds = this.selectedImgIds.filter(id => id !== s.imgId); } 
                                else { this.selectedImgIds.push(s.imgId); }
                                this.selectedImgId = this.selectedImgIds[this.selectedImgIds.length - 1] || null;
                                this.draggedId = null; this.dragStartInfo = null;
                                this.render(); return;
                            } else if (e.shiftKey) {
                                if (isAlreadySelected) {
                                    this.draggedId = s.imgId;
                                    const items = this.selectedImgIds.map(id => { const img = this.images.find(i => i.id === id); return { id: img.id, type: 'image', startX: img.x, startY: img.y }; });
                                    this.dragStartInfo = { mouseX: pos.x, mouseY: pos.y, items: items };
                                    this.render(); return;
                                }
                            }
                            if (this.selectedImgIds.includes(s.imgId)) {
                                this.draggedId = s.imgId;
                                const dragItems = this.selectedImgIds.map(id => { const img = this.images.find(i => i.id === id); return { id: img.id, type: 'image', startX: img.x, startY: img.y }; });
                                this.dragStartInfo = { mouseX: pos.x, mouseY: pos.y, items: dragItems };
                            }
                            this.render(); return;
                        }
                    }
                    if (!isMulti) {
                        this.deselectAll();
                        this.isBoxSelecting = true; this.boxStart = { x: pos.x, y: pos.y }; this.boxEnd = { x: pos.x, y: pos.y };
                        this.render();
                    }
                }
            },
            handleMove(e) {
                // --- è™•ç†è§¸æ§é›™æŒ‡ç¸®æ”¾èˆ‡å¹³ç§» ---
                if (e.touches && e.touches.length === 2 && this.isTouchZooming) {
                    const dx = e.touches[0].clientX - e.touches[1].clientX;
                    const dy = e.touches[0].clientY - e.touches[1].clientY;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    const newCenter = {
                        x: (e.touches[0].clientX + e.touches[1].clientX) / 2,
                        y: (e.touches[0].clientY + e.touches[1].clientY) / 2
                    };

                    // 1. è™•ç†ç¸®æ”¾
                    const scaleChange = dist / this.lastPinchDist;
                    const newZoom = Math.max(0.1, Math.min(5, this.viewZoom * scaleChange));
                    this.viewZoom = parseFloat(newZoom.toFixed(3));
                    this.lastPinchDist = dist;

                    // 2. è™•ç†å¹³ç§» (åŒæ­¥ç§»å‹•)
                    this.panX += (newCenter.x - this.touchCenter.x);
                    this.panY += (newCenter.y - this.touchCenter.y);
                    this.touchCenter = newCenter;
                    return;
                }

                if (this.isPanning) { 
                    const dx = e.clientX - this.lastX; 
                    const dy = e.clientY - this.lastY; 
                    this.panX += dx; this.panY += dy; 
                    this.lastX = e.clientX; this.lastY = e.clientY; 
                    return; 
                }
                if (this.isRightScaling && this.selectedImgId) { 
                    const dy = e.clientY - this.lastY; 
                    this.lastY = e.clientY; 
                    const img = this.getSelectedImg(); 
                    if (img) { img.scale = Math.max(0.05, img.scale - (dy * 0.01)); this.render(); } 
                    return; 
                }
                const pos = this.getPointerPos(e);
                if (this.isBoxSelecting) { this.boxEnd = { x: pos.x, y: pos.y }; this.render(); return; }
                if (this.isUniTransforming) {
                    const t = this.transformStart; 
                    const target = this.selectedStickerId ? this.getSelectedSticker() : this.getSelectedText();
                    const currentAngle = Math.atan2(pos.y - t.cy, pos.x - t.cx); 
                    target.rotation = t.rotation + (currentAngle - t.angle) * (180 / Math.PI);
                    const scaleRatio = Math.hypot(pos.x - t.cx, pos.y - t.cy) / t.dist;
                    if (this.selectedStickerId) target.scale = Math.max(0.1, t.scale * scaleRatio); 
                    else target.fontSize = Math.max(10, Math.round(t.fontSize * scaleRatio));
                    this.render(); return;
                }

                if(!this.draggedId || !this.dragStartInfo) return;
                
                let totalDx = pos.x - this.dragStartInfo.mouseX; 
                let totalDy = pos.y - this.dragStartInfo.mouseY;

                if (e.shiftKey) {
                    const angle = Math.atan2(totalDy, totalDx);
                    const dist = Math.hypot(totalDx, totalDy);
                    const snappedAngle = Math.round(angle / (Math.PI / 4)) * (Math.PI / 4);
                    totalDx = Math.cos(snappedAngle) * dist;
                    totalDy = Math.sin(snappedAngle) * dist;
                }
                
                this.dragStartInfo.items.forEach(item => {
                    if (item.type === 'site') {
                        const s = this.sites.find(site => site.id === item.id); 
                        if (s) { s.x = item.startX + totalDx; s.y = item.startY + totalDy; }
                    } else if (item.type === 'text') {
                        const t = this.texts.find(text => text.id === item.id); 
                        if (t) { t.x = item.startX + totalDx; t.y = item.startY + totalDy; }
                    } else if (item.type === 'sticker') {
                        const s = this.stickers.find(st => st.id === item.id); 
                        if (s) { s.x = item.startX + totalDx; s.y = item.startY + totalDy; }
                    } else if (item.type === 'image') {
                        const img = this.images.find(i => i.id === item.id); 
                        if (img) { img.x = item.startX + totalDx; img.y = item.startY + totalDy; }
                    }
                });
                this.render();
            },
            handleEnd(e) {
                // çµæŸé›™æŒ‡ç¸®æ”¾ç‹€æ…‹
                this.isTouchZooming = false;
                this.isPanning = false; this.isUniTransforming = false; if (this.isRightScaling) { this.isRightScaling = false; this.saveState(); }
                
                const pos = this.getPointerPos(e);
                const dist = this.mouseDownPos ? Math.hypot(pos.x - this.mouseDownPos.x, pos.y - this.mouseDownPos.y) : 0;
                
                if (e.shiftKey && dist < 5) {
                    if (this.mode === 'text' && this.lastPotentialHit) {
                        const hit = this.lastPotentialHit;
                        if (hit.type === 'sticker') {
                            if (this.selectedStickerIds.includes(hit.item.id)) this.selectedStickerIds = this.selectedStickerIds.filter(id => id !== hit.item.id);
                            else this.selectedStickerIds.push(hit.item.id);
                            this.selectedStickerId = this.selectedStickerIds.length > 0 ? this.selectedStickerIds[this.selectedStickerIds.length-1] : null;
                        } else {
                            if (this.selectedTextIds.includes(hit.item.id)) this.selectedTextIds = this.selectedTextIds.filter(id => id !== hit.item.id);
                            else this.selectedTextIds.push(hit.item.id);
                            this.selectedTextId = this.selectedTextIds.length > 0 ? this.selectedTextIds[this.selectedTextIds.length-1] : null;
                        }
                    } else if (this.mode === 'layout' && this.lastPotentialSite) {
                        const s = this.lastPotentialSite;
                        if (this.selectedSiteIds.includes(s.id)) this.selectedSiteIds = this.selectedSiteIds.filter(id => id !== s.id);
                        else this.selectedSiteIds.push(s.id);
                        this.selectedSiteId = s.id; this.selectedImgId = s.imgId;
                    } else if (this.mode === 'image' && this.lastPotentialImgId) {
                        const id = this.lastPotentialImgId;
                        if (this.selectedImgIds.includes(id)) this.selectedImgIds = this.selectedImgIds.filter(i => i !== id);
                        else this.selectedImgIds.push(id);
                        this.selectedImgId = this.selectedImgIds[this.selectedImgIds.length - 1] || null;
                    }
                }
                this.lastPotentialHit = null;
                this.lastPotentialImgId = null;
                this.lastPotentialSite = null;
                this.mouseDownPos = null;

                if (this.isBoxSelecting) {
                    this.isBoxSelecting = false;
                    const x1 = Math.min(this.boxStart.x, this.boxEnd.x); const y1 = Math.min(this.boxStart.y, this.boxEnd.y);
                    const x2 = Math.max(this.boxStart.x, this.boxEnd.x); const y2 = Math.max(this.boxStart.y, this.boxEnd.y);
                    if (Math.abs(x2 - x1) < 5 && Math.abs(y2 - y1) < 5) { this.render(); return; }

                    if (this.mode === 'layout') {
                        const newSelection = [];
                        this.sites.forEach(s => { if (s.x >= x1 && s.x <= x2 && s.y >= y1 && s.y <= y2) newSelection.push(s.id); });
                        if (newSelection.length > 0) {
                            this.selectedSiteIds = newSelection; this.selectedSiteId = newSelection[newSelection.length-1];
                            const ref = this.sites.find(s=>s.id === this.selectedSiteId); if(ref) this.selectedImgId = ref.imgId;
                        } else { this.deselectAll(); }
                    } else if (this.mode === 'text') {
                        const tIds = []; this.texts.forEach(t => { if (t.x >= x1 && t.x <= x2 && t.y >= y1 && t.y <= y2) tIds.push(t.id); });
                        const sIds = []; this.stickers.forEach(s => { if (s.x >= x1 && s.x <= x2 && s.y >= y1 && s.y <= y2) sIds.push(s.id); });
                        if (tIds.length > 0 || sIds.length > 0) {
                            this.selectedTextIds = tIds; this.selectedTextId = tIds.length > 0 ? tIds[tIds.length-1] : null;
                            this.selectedStickerIds = sIds; this.selectedStickerId = sIds.length > 0 ? sIds[sIds.length-1] : null;
                        } else { this.deselectAll(); }
                    }
                    this.render(); return;
                }
                if (this.draggedId) this.saveState();
                this.draggedId = null; this.dragStartInfo = null; this.render();
            },
            handleWheel(e) { e.preventDefault(); const zoomSpeed = 0.05; const newZoom = this.viewZoom - (e.deltaY > 0 ? zoomSpeed : -zoomSpeed); this.viewZoom = Math.max(0.1, Math.min(5, newZoom)); },
            askReset() { this.confirmTitle = this.ui.msgResetTitle; this.confirmMsg = this.ui.msgResetBody; this.pendingAction = 'reset'; this.isAlert = false; this.showConfirm = true; },
            askClear() { this.confirmTitle = this.ui.msgClearTitle; this.confirmMsg = this.ui.msgClearBody; this.pendingAction = 'clear'; this.isAlert = false; this.showConfirm = true; },
            showAlert(title, msg) { this.confirmTitle = title; this.confirmMsg = msg; this.isAlert = true; this.pendingAction = null; this.showConfirm = true; },
            executeConfirm() { if(this.isAlert) { this.showConfirm = false; return; } if (this.pendingAction === 'reset') this.doReset(); else if (this.pendingAction === 'clear') this.doClear(); this.showConfirm = false; this.pendingAction = null; },
            doReset() {
                this.sites = [];
                const numImages = this.images.length;
                if (numImages === 0) return;

                // 1. åˆå§‹éš¨æ©Ÿæ•£ä½ˆ (ç¨å¾®é¿é–‹é‚Šç·£)
                let tempSites = this.images.map((img, i) => {
                    return {
                        id: Date.now() + Math.random() + i,
                        imgId: img.id,
                        x: this.outWidth * 0.2 + Math.random() * (this.outWidth * 0.6),
                        y: this.outHeight * 0.2 + Math.random() * (this.outHeight * 0.6)
                    };
                });

                // 2. åŸ·è¡Œã€Œå‹åŸƒå¾·æ”¾é¬†ã€ (Lloyd's Relaxation) ç–Šä»£ 3 æ¬¡
                // é€™æœƒè®“ç¯€é»è‡ªå‹•æ¨æ“ ï¼Œé”æˆä½ èªªçš„ã€Œä½”æ¯”å·®ä¸å¤šã€
                for (let iter = 0; iter < 3; iter++) {
                    // å»ºç«‹è‡¨æ™‚çš„ Delaunay èˆ‡ Voronoi ä¾†è¨ˆç®—ç•¶å‰ä½ç½®çš„æ ¼å­
                    const points = tempSites.map(s => [s.x, s.y]);
                    const delaunay = d3.Delaunay.from(points);
                    const voronoi = delaunay.voronoi([0, 0, this.outWidth, this.outHeight]);

                    tempSites.forEach((site, i) => {
                        const polygon = voronoi.cellPolygon(i);
                        if (polygon) {
                            // è¨ˆç®—å¤šé‚Šå½¢çš„é‡å¿ƒ (æ‰€æœ‰é ‚é»çš„å¹³å‡å€¼)
                            let area = 0, cx = 0, cy = 0;
                            for (let j = 0; j < polygon.length - 1; j++) {
                                const [x0, y0] = polygon[j];
                                const [x1, y1] = polygon[j+1];
                                const a = x0 * y1 - x1 * y0;
                                area += a;
                                cx += (x0 + x1) * a;
                                cy += (y0 + y1) * a;
                            }
                            site.x = cx / (3 * area);
                            site.y = cy / (3 * area);
                        }
                    });
                }

                // 3. æ›´æ–°åœ–ç‰‡ç¸®æ”¾æ¯”ä¾‹èˆ‡ä½ç½®
                this.images.forEach(img => {
                    const targetSize = Math.min(this.outWidth, this.outHeight) * 0.5;
                    img.x = 0;
                    img.y = 0;
                    img.rotation = 0;
                    if (img.obj) {
                        img.scale = targetSize / Math.max(img.obj.width, img.obj.height);
                    }
                });

                this.sites = tempSites;
                this.render();
                this.saveState();
            },
            doClear() { 
                this.sites = []; this.images = []; this.texts = []; 
                this.stickers = []; // ç¢ºä¿è²¼åœ–è¢«æ¸…ç©º
                
                // é‡ç½®æ‰€æœ‰é¸å– ID
                this.selectedImgId = null; this.selectedImgIds = [];
                this.selectedTextId = null; this.selectedTextIds = []; 
                this.selectedSiteId = null; this.selectedSiteIds = []; 
                this.selectedStickerId = null; this.selectedStickerIds = [];

                this.render(); 
                this.saveState(); 
            },
            saveProject() { 
                // 1. è™•ç†åº•åœ–æ ¼ï¼šä¸å„²å­˜ srcData
                const safeImages = this.images.map(img => ({ 
                    id: img.id, name: img.name, size: img.size, 
                    lastModified: img.lastModified, isEmpty: img.isEmpty, 
                    x: img.x, y: img.y, scale: img.scale, scaleX: img.scaleX, rotation: img.rotation 
                })); 
                
                // 2. è™•ç†è²¼åœ–ï¼šä¸å„²å­˜ srcData
                const safeStickers = this.stickers.map(s => ({
                    id: s.id, name: s.name, x: s.x, y: s.y, scale: s.scale, scaleX: s.scaleX,
                    rotation: s.rotation, alpha: s.alpha, zIndex: s.zIndex,
                    width: s.width, height: s.height, type: 'sticker'
                }));

                const data = { 
                    width: this.outWidth, height: this.outHeight, gap: this.gap, 
                    cornerRadius: this.cornerRadius, marginTop: this.marginTop, 
                    marginBottom: this.marginBottom, marginLeft: this.marginLeft, 
                    marginRight: this.marginRight, bgType: this.bgType, 
                    bgColor1: this.bgColor1, bgAlpha1: this.bgAlpha1, 
                    bgColor2: this.bgColor2, bgAlpha2: this.bgAlpha2, bgAngle: this.bgAngle, 
                    imgBorder: this.imgBorder, imgBorderColor: this.imgBorderColor, 
                    imgBorderWidth: this.imgBorderWidth, imgBorderAlpha: this.imgBorderAlpha, 
                    sites: this.sites, texts: this.texts, 
                    images: safeImages,
                    stickers: safeStickers // è¼•é‡åŒ–è²¼åœ–åˆ—è¡¨
                }; 
                const blob = new Blob([JSON.stringify(data)], {type: "application/json"}); 
                this.saveFileWithPicker(blob, `collage-${Date.now()}.json`, 'json'); 
            },            
                loadProject(e) { 
                const file = e.target.files[0]; 
                if (!file) return; 
                const reader = new FileReader(); 
                reader.onload = (evt) => { 
                    try {
                        const data = JSON.parse(evt.target.result); 
                        
                        // 1. æ¸…ç©ºèˆŠç‹€æ…‹ä¸¦å¥—ç”¨æ–°å°ˆæ¡ˆåƒæ•¸ (å«å…¨åŸŸè¨­å®šã€ç•™ç™½ã€é‚Šæ¡†ã€èƒŒæ™¯)
                        Object.assign(this, { 
                            outWidth: data.width || 1920, outHeight: data.height || 1080, 
                            gap: data.gap || 0, cornerRadius: data.cornerRadius || 0, 
                            marginTop: data.marginTop || 0, marginBottom: data.marginBottom || 0, 
                            marginLeft: data.marginLeft || 0, marginRight: data.marginRight || 0, 
                            bgType: data.bgType || 'solid', bgColor1: data.bgColor1 || '#111', bgAlpha1: data.bgAlpha1 || 1, 
                            bgColor2: data.bgColor2 || '#333', bgAlpha2: data.bgAlpha2 || 1, bgAngle: data.bgAngle || 135, 
                            imgBorder: data.imgBorder || false, imgBorderColor: data.imgBorderColor || '#fff', 
                            imgBorderWidth: data.imgBorderWidth || 5, imgBorderAlpha: data.imgBorderAlpha || 1, 
                            sites: data.sites || [], 
                            texts: data.texts || [], 
                            stickers: [], // æ˜ç¢ºæ¸…ç©ºè²¼åœ–é™£åˆ—
                            images: [],   // æ˜ç¢ºæ¸…ç©ºåœ–ç‰‡é™£åˆ—
                            selectedImgId: null, selectedTextId: null, selectedTextIds: [], 
                            selectedSiteId: null, selectedSiteIds: [], selectedStickerId: null, selectedStickerIds: []
                        }); 

                        // 2. å»ºç«‹åœ–ç‰‡èˆ‡è²¼åœ–è¼‰å…¥è¨ˆæ•¸å™¨
                        let imagesToLoad = (data.images ? data.images.length : 0) + (data.stickers ? data.stickers.length : 0);
                        const triggerRender = () => {
                            if (imagesToLoad > 0) imagesToLoad--;
                            this.render(); // æ¯è¼‰å…¥ä¸€å¼µå°±ç¹ªè£½ä¸€æ¬¡ï¼Œå¢åŠ å³æ™‚æ„Ÿ
                        };

                        // 3. é‡å»ºæ’ç‰ˆåœ–ç‰‡ç‰©ä»¶èˆ‡ Registry
                        if (data.images) {
                            data.images.forEach(imgData => { 
                                if (imgData.srcData) {
                                    const imgObj = new Image();
                                    imgObj.onload = triggerRender;
                                    imgObj.onerror = triggerRender;
                                    imgObj.src = imgData.srcData;
                                    imgData.obj = imgObj;
                                    this.imageRegistry[String(imgData.id)] = { obj: imgObj, srcData: imgData.srcData };
                                } else { 
                                    imgData.obj = null; 
                                    if (imagesToLoad > 0) imagesToLoad--;
                                }
                                this.images.push(imgData); 
                            });
                        }

                        // 4. é‡å»ºè²¼åœ–ç‰©ä»¶èˆ‡ Registry
                        if (data.stickers) {
                            data.stickers.forEach(stkData => {
                                if (stkData.srcData) {
                                    const stkObj = new Image();
                                    stkObj.onload = triggerRender;
                                    stkObj.onerror = triggerRender;
                                    stkObj.src = stkData.srcData;
                                    stkData.obj = stkObj;
                                    this.imageRegistry[String(stkData.id)] = { obj: stkObj, srcData: stkData.srcData };
                                } else { 
                                    stkData.obj = null;
                                    if (imagesToLoad > 0) imagesToLoad--;
                                }
                                this.stickers.push(stkData);
                            });
                        }

                        // 5. ç«‹å³è¨ˆç®—ç¶²æ ¼ä¸¦é‡ç¹ª
                        this.$nextTick(() => {
                            this.updateVoronoi(); // æ ¸å¿ƒï¼šè®€å–å¾Œç«‹å³è¨ˆç®—ç¶²æ ¼
                            this.render(); 
                            this.fitView();       // è‡ªå‹•ç¸®æ”¾ç•«å¸ƒé©æ‡‰è¢å¹•
                            this.saveState();     // å„²å­˜ç‚ºæ­·å²èµ·é»
                        });
                    } catch (err) {
                        console.error("Project load error:", err);
                        alert("å°ˆæ¡ˆè®€å–å¤±æ•—ï¼Œè«‹ç¢ºèªæª”æ¡ˆæ ¼å¼æ˜¯å¦æ­£ç¢ºã€‚");
                    }
                };
                reader.readAsText(file); 
                e.target.value = ''; 
            },

            download() {
                this.finishEdit(); // åœæ­¢æ–‡å­—ç·¨è¼¯æ¨¡å¼
                
                const prevMode = this.mode;
                this.mode = 'export'; // é€²å…¥åŒ¯å‡ºæ¨¡å¼
                
                // æš«å­˜ç›®å‰çš„é¸å–ç‹€æ…‹ï¼Œä¸¦åœ¨åŒ¯å‡ºå‰æ¸…ç©º (ç¢ºä¿ PNG æ²’æœ‰è™›ç·šæ¡†)
                const selectionCache = {
                    img: this.selectedImgId,
                    txt: this.selectedTextId,
                    txts: [...this.selectedTextIds],
                    site: this.selectedSiteId,
                    sites: [...this.selectedSiteIds],
                    stk: this.selectedStickerId,
                    stks: [...this.selectedStickerIds]
                };
                this.deselectAll(); 

                // æš«å­˜ç•«å¸ƒè®Šè¦–çª—è¨­å®š
                const prevZoom = this.viewZoom;
                const prevPanX = this.panX;
                const prevPanY = this.panY;

                // æ­¸é›¶ç•«å¸ƒä»¥ 1:1 åŒ¯å‡º
                this.viewZoom = 1; this.panX = 0; this.panY = 0;

                this.$nextTick(() => {
                    this.updateVoronoi(); // ç¢ºä¿åŒ¯å‡ºæ™‚ç¶²æ ¼æ­£ç¢º
                    this.render(); 
                    setTimeout(() => {
                        this.$refs.canvas.toBlob(async (blob) => {
                            if (blob) {
                                await this.saveFileWithPicker(blob, `collage-${Date.now()}.png`, 'png');
                            }
                            
                            // æ¢å¾©åŒ¯å‡ºå‰çš„æ‰€æœ‰ç‹€æ…‹
                            this.mode = prevMode;
                            this.viewZoom = prevZoom;
                            this.panX = prevPanX;
                            this.panY = prevPanY;
                            
                            this.selectedImgId = selectionCache.img;
                            this.selectedTextId = selectionCache.txt;
                            this.selectedTextIds = selectionCache.txts;
                            this.selectedSiteId = selectionCache.site;
                            this.selectedSiteIds = selectionCache.sites;
                            this.selectedStickerId = selectionCache.stk;
                            this.selectedStickerIds = selectionCache.stks;
                            
                            this.render(); 
                        }, 'image/png', 1.0);
                    }, 100);
                });
            },
            toggleConnectMode() { if (!this.selectedImgId) return; this.isConnecting = !this.isConnecting; this.isBoxSelecting = false; this.isSwapping = false; },
            updateTemplate() { if (this.mode === 'template' && this.lastTemplateType) this.applyPreset(this.lastTemplateType); },
            applyPreset(type) {
                const isUpdateMode = (this.lastTemplateType === type && this.lastTplCount === this.tplCount); this.lastTemplateType = type; this.lastTplCount = this.tplCount;
                const w = this.outWidth, h = this.outHeight, cx = this.tplCenterX, cy = this.tplCenterY, totalCount = this.tplCount; 
                const calcLayers = Math.max(1, Math.ceil(this.tplSpacing / 3)); const baseInnerR = 50; const maxR = baseInnerR + this.tplPadding * 1.8; const fatness = 0.5 + (this.tplStrength / 10) * 2.0; const jitter = this.tplJitter;
                let imgQueue = []; if (isUpdateMode) { this.images = this.images.filter(img => !img.isEmpty && img.name !== 'Ghost' && img.name !== 'RingWall' && img.name !== 'SpokeWall' && img.name !== 'VWall'); this.sites = []; } else { imgQueue = this.images.filter(i => !i.isEmpty).map(img => ({ ...img, x: 0, y: 0, scale: 1, rotation: 0 })); this.sites = []; this.images = []; this.selectedImgId = null; this.selectedSiteIds = []; }
                let uniqueCounter = 0; const getUniqueId = () => Date.now() + (uniqueCounter++) + Math.random(); let firstImageId = null;
                const addKaleidoBone = (name, angle, rStart, rEnd, widthMod = 1.0, angleOffset = 0, imageIndex = -1) => {
                    let id; if (isUpdateMode) { if (imageIndex >= 0 && imageIndex < this.images.length) id = this.images[imageIndex].id; else { id = getUniqueId(); this.images.push({id, obj:null, srcData:null, name, isEmpty:false, size:0, lastModified:Date.now(), x:0, y:0, scale:1, rotation:0}); } } 
                    else { id = getUniqueId(); if (!firstImageId) firstImageId = id; const existing = imgQueue.shift(); if (existing) { existing.id = id; this.images.push(existing); } else { this.images.push({id, obj:null, srcData:null, name, isEmpty:false, size:0, lastModified:Date.now(), x:0, y:0, scale:1, rotation:0}); } }
                    const depth = rEnd - rStart; const boneLen = depth * Math.min(0.95, 0.3 + 0.1 * this.tplStrength); const centerR = rStart + depth / 2; const boneStart = centerR - boneLen / 2; const boneEnd = centerR + boneLen / 2; const nodes = 5; 
                    for(let k=0; k<nodes; k++) { const t = k / (nodes - 1); const currR = boneStart + (boneEnd - boneStart) * t; const baseW = 15 * fatness * widthMod; const currentWidth = baseW * (0.7 + t * 0.6); const sidePoints = Math.max(1, Math.ceil(fatness * widthMod)); for(let s=0; s<sidePoints; s++) { const spread = sidePoints === 1 ? 0 : (s / (sidePoints-1) - 0.5); const wAngle = (currentWidth * spread) / currR; const finalAngle = angle + wAngle + angleOffset; const jx = (Math.random()-0.5) * jitter; const jy = (Math.random()-0.5) * jitter; this.sites.push({ id: getUniqueId(), imgId: id, x: cx + Math.cos(finalAngle) * currR + jx, y: cy + Math.sin(finalAngle) * currR + jy }); } }
                };
                const addWallRing = (r, density = 1.0) => { if (density <= 0) return; const circum = 2 * Math.PI * r; const steps = Math.ceil((circum / 10) * density); const actualSteps = Math.max(Math.floor(density * 3), steps); const ghostId = getUniqueId(); this.images.push({ id: ghostId, name: 'RingWall', isEmpty: true, size: 0, lastModified: Date.now(), x:0, y:0, scale:1, rotation:0 }); for(let i=0; i<actualSteps; i++) { const a = (i/actualSteps) * Math.PI * 2; const thicknessScatter = Math.min(5, density * 1.5); const rOffset = (Math.random() - 0.5) * thicknessScatter; const jx = (Math.random()-0.5) * jitter; const jy = (Math.random()-0.5) * jitter; this.sites.push({ id: getUniqueId(), imgId: ghostId, x: cx + Math.cos(a) * (r + rOffset) + jx, y: cy + Math.sin(a) * (r + rOffset) + jy }); } };
                const addSpokeWall = (angle, rMin, rMax, density = 1.0) => { if (density <= 0) return; const len = rMax - rMin; const steps = Math.ceil((len / 100) * density); const actualSteps = Math.max(Math.floor(density * 2), steps); const ghostId = getUniqueId(); this.images.push({ id: ghostId, name: 'SpokeWall', isEmpty: true, size: 0, lastModified: Date.now(), x:0, y:0, scale:1, rotation:0 }); for(let i=0; i<=actualSteps; i++) { const r = rMin + len * (i/actualSteps); const thicknessScatter = Math.min(5, density * 1.5); const spread = (Math.random() - 0.5) * thicknessScatter; const jx = (Math.random()-0.5) * jitter + spread; const jy = (Math.random()-0.5) * jitter + spread; this.sites.push({ id: getUniqueId(), imgId: ghostId, x: cx + Math.cos(angle)*r + jx, y: cy + Math.sin(angle)*r + jy }); } };
                
                let globalImgIndex = 0; 
                if (type === 'flower') {
                    const rInner = Math.max(10, 10 + (this.tplPadding * 0.15)); const rOuter = 150 + (this.tplPadding * 3.5); const rImage = rInner + 40 + (this.tplPadding * 0.2); const wallDensity = this.tplSpacing <= 1 ? 0 : (this.tplSpacing - 1) * 0.08; const spreadRadius = (this.tplStrength - 1) * 5; const pointCount = (this.tplStrength <= 1) ? 1 : Math.max(3, Math.ceil(this.tplStrength * 1)); 
                    for(let i=0; i<totalCount; i++) {
                        const angle = (i / totalCount) * Math.PI * 2; let imgId;
                        if (isUpdateMode && this.images[globalImgIndex]) { imgId = this.images[globalImgIndex].id; } else { imgId = getUniqueId(); if (!firstImageId) firstImageId = imgId; if (!isUpdateMode) { const existing = imgQueue.shift(); if (existing) { existing.id = imgId; this.images.push(existing); } else { this.images.push({id:imgId, obj:null, srcData:null, name:`Simp-${i}`, isEmpty:false, size:0, lastModified:Date.now(), x:0, y:0, scale:1, rotation:0}); } } }
                        const centerX = cx + Math.cos(angle) * rImage; const centerY = cy + Math.sin(angle) * rImage;
                        for(let k=0; k<pointCount; k++) { let px, py; if (k === 0) { px = centerX; py = centerY; } else { const subAngle = ((k - 1) / (pointCount - 1)) * Math.PI * 2; px = centerX + Math.cos(subAngle) * spreadRadius; py = centerY + Math.sin(subAngle) * spreadRadius; } const jx = (Math.random()-0.5) * jitter; const jy = (Math.random()-0.5) * jitter; this.sites.push({ id: getUniqueId(), imgId: imgId, x: px + jx, y: py + jy }); } globalImgIndex++; const midA = angle + (Math.PI / totalCount) / 2; addSpokeWall(midA, rInner, rOuter, wallDensity);
                    }
                    addWallRing(rOuter, wallDensity); addWallRing(rInner, wallDensity);
                } else if (type === 'radial') {
                    const rStart = baseInnerR; const rEnd = maxR; const twist = Math.PI / 4; for(let i=0; i<totalCount; i++) { const angle = (i / totalCount) * Math.PI * 2; addKaleidoBone(`Ray-${i}`, angle, rStart, rEnd, 0.8, twist, globalImgIndex++); } addWallRing(rStart - 10); addWallRing(maxR + 10);
                } else if (type === 'grid') {
                    // 1. æ ¹æ“šç•«å¸ƒæ¯”ä¾‹èˆ‡ç¸½æ•¸æ±ºå®šç¸½è¡Œæ•¸
                    const ratio = w / h;
                    const rows = Math.max(1, Math.round(Math.sqrt(totalCount / ratio)));
                    const rowHeight = h / rows;

                    // 2. è¨ˆç®—æ¯è¡ŒåŸºç¤æ•¸é‡èˆ‡ã€Œé¤˜æ•¸ã€
                    const baseCols = Math.floor(totalCount / rows);
                    let extra = totalCount % rows;

                    let currentImgIdx = 0;
                    for (let r = 0; r < rows; r++) {
                        const colsInRow = baseCols + (extra > 0 ? 1 : 0);
                        extra--;

                        const colWidth = w / colsInRow;
                        const y = rowHeight * (r + 0.5);

                        for (let c = 0; c < colsInRow; c++) {
                            const x = colWidth * (c + 0.5);

                            let id;
                            if (isUpdateMode && this.images[globalImgIndex]) {
                                id = this.images[globalImgIndex].id;
                            } else {
                                id = getUniqueId();
                                if (!firstImageId) firstImageId = id;
                                if (!isUpdateMode) {
                                    const existing = imgQueue.shift();
                                    if (existing) { existing.id = id; this.images.push(existing); }
                                    else { this.images.push({id, obj:null, srcData:null, name:`Fill-${currentImgIdx+1}`, isEmpty:false, size:0, lastModified:Date.now(), x:0, y:0, scale:1, rotation:0}); }
                                }
                            }

                            // é€éå¾®å°çš„æŠ–å‹•(Jitter)è®“åˆ†å‰²ç·šç”¢ç”Ÿè‡ªç„¶çš„å‹•æ…‹æ„Ÿ
                            const jx = (Math.random() - 0.5) * this.tplJitter * (colWidth / 20);
                            const jy = (Math.random() - 0.5) * this.tplJitter * (rowHeight / 20);
                            
                            this.sites.push({ id: getUniqueId(), imgId: id, x: x + jx, y: y + jy });
                            this.sites.push({ id: getUniqueId(), imgId: id, x: x - jx, y: y - jy });

                            globalImgIndex++;
                            currentImgIdx++;
                        }
                    }
                } else if (type === 'circle') {
                    // --- å…¨åƒæ•¸é€£å‹•ï¼šå‹•æ…‹èºæ—‹å¼•åŠ›å ´ ---
                    const totalItems = totalCount;
                    const maxRadius = this.tplPadding * 2.5; // Padding æ±ºå®šæ˜Ÿç³»ç¸½å¤§å°
                    const spiralTension = this.tplSpacing * 0.5; // Spacing æ±ºå®šèºæ—‹æ—‹è½‰çš„ç·Šåº¦
                    const jitter = this.tplJitter * 2; // Jitter æ±ºå®šéš¨æ©Ÿæ··äº‚åº¦
                    const strength = Math.max(1, this.tplStrength); // Strength æ±ºå®šæ¯å¼µåœ–çš„å½¢ç‹€è¤‡é›œåº¦
                    
                    for (let i = 0; i < totalItems; i++) {
                        // 1. èºæ—‹è·¯å¾‘è¨ˆç®—
                        const t = i / totalItems; // 0 åˆ° 1 çš„é€²åº¦
                        // è§’åº¦éš¨é€²åº¦å¢åŠ ï¼Œä¸¦å— Spacing å½±éŸ¿æ—‹è½‰åœˆæ•¸
                        const angle = t * Math.PI * 2 * spiralTension;
                        // åŠå¾‘éš¨é€²åº¦ç·šæ€§å¢åŠ ï¼Œå— Padding å½±éŸ¿ç¯„åœ
                        const r = t * maxRadius;

                        // 2. è™•ç†åœ–ç‰‡å¯¦é«”
                        let id;
                        if (isUpdateMode && this.images[globalImgIndex]) {
                            id = this.images[globalImgIndex].id;
                        } else {
                            id = getUniqueId();
                            if (!firstImageId) firstImageId = id;
                            if (!isUpdateMode) {
                                const existing = imgQueue.shift();
                                if (existing) { existing.id = id; this.images.push(existing); }
                                else { this.images.push({id, obj:null, srcData:null, name:`Spiral-${i}`, isEmpty:false, size:0, lastModified:Date.now(), x:0, y:0, scale:1, rotation:0}); }
                            }
                        }

                        // 3. å¤šé‡ç¯€é»ç”Ÿæˆ (Strength çš„ä½œç”¨)
                        // æˆ‘å€‘åœ¨è¨ˆç®—å‡ºçš„èºæ—‹ä¸­å¿ƒé»å‘¨åœï¼Œæ ¹æ“š Strength æ•¸é‡æ•£ä½ˆé»
                        for (let s = 0; s < strength; s++) {
                            // æ¯å€‹å­ç¯€é»åœ¨ä¸­å¿ƒé»å‘¨åœåšå¾®å¹…æ“´æ•£
                            const subAngle = (s / strength) * Math.PI * 2;
                            const subDist = strength > 1 ? (strength * 5) : 0;
                            
                            const jx = (Math.random() - 0.5) * jitter;
                            const jy = (Math.random() - 0.5) * jitter;

                            const finalX = this.tplCenterX + Math.cos(angle) * r + Math.cos(subAngle) * subDist + jx;
                            const finalY = this.tplCenterY + Math.sin(angle) * r + Math.sin(subAngle) * subDist + jy;

                            this.sites.push({
                                id: getUniqueId(),
                                imgId: id,
                                x: finalX,
                                y: finalY
                            });
                        }
                        globalImgIndex++;
                    }
                } else if (type === 'honeycomb') {
                    let remaining = totalCount; const totalDepth = maxR - baseInnerR; const layerDepth = totalDepth / calcLayers; for(let L=0; L<calcLayers; L++) { if (remaining <= 0) break; const rS = baseInnerR + layerDepth * L; const rE = baseInnerR + layerDepth * (L + 1); let countInLayer = (L === calcLayers-1) ? remaining : Math.min(remaining, Math.max(3, Math.ceil(remaining / (calcLayers-L)))); const stagger = (L % 2) * (Math.PI / countInLayer); for(let i=0; i<countInLayer; i++) { const angle = (i / countInLayer) * Math.PI * 2 + stagger; addKaleidoBone(`Hex${L}-${i}`, angle, rS, rE, 1.2, 0, globalImgIndex++); } if (L < calcLayers-1) addWallRing(rE); remaining -= countInLayer; } addWallRing(baseInnerR - 10);
                } else if (type === 'masonry') {
                    const goldenAngle = Math.PI * (3 - Math.sqrt(5)); const totalDepth = maxR - baseInnerR; const itemDepth = totalDepth / Math.sqrt(totalCount) * 1.5; for(let i=0; i<totalCount; i++) { const t = i / (totalCount - 1 || 1); const rCenter = baseInnerR + t * (maxR - baseInnerR); const rS = Math.max(baseInnerR, rCenter - itemDepth/2); const rE = Math.min(maxR, rCenter + itemDepth/2); const angle = i * goldenAngle; addKaleidoBone(`Spiral-${i}`, angle, rS, rE, 1.0, 0, globalImgIndex++); } addWallRing(baseInnerR - 10);
                }
                addWallRing(Math.max(w,h) * 0.85);
                if (firstImageId && !isUpdateMode) this.selectedImgId = firstImageId;
                this.render(); this.saveState();
            },

            normalizeZIndices() {
                const all = [...this.texts, ...this.stickers].sort((a, b) => (a.zIndex || 0) - (b.zIndex || 0));
                const bgItems = all.filter(i => i.zIndex < this.gridZIndex);
                const fgItems = all.filter(i => i.zIndex >= this.gridZIndex);

                bgItems.forEach((item, idx) => { item.zIndex = idx + 1; });
                fgItems.forEach((item, idx) => { item.zIndex = this.gridZIndex + 1 + idx; });
            },

            // 2. å–å¾—ç›®å‰æœ€é«˜å±¤ç´š
            getNextZIndex() {
                const maxZ = Math.max(this.gridZIndex, ...this.texts.map(t => t.zIndex || 0), ...this.stickers.map(s => s.zIndex || 0));
                return maxZ + 1;
            },

            // 3. çµ±ä¸€çš„åœ–å±¤æ§åˆ¶å‡½å¼ (å–ä»£åŸæœ‰çš„ changeTextLayer / changeStickerLayer)
             moveLayer(action) {
                const selIds = [...this.selectedTextIds, ...this.selectedStickerIds];
                if (selIds.length === 0) return;

                // 1. å°‡æ‰€æœ‰ç‰©ä»¶ä¾ç›®å‰ zIndex æ’åº
                let all = [...this.texts, ...this.stickers].sort((a, b) => (a.zIndex || 0) - (b.zIndex || 0));
                
                // 2. æ ¸å¿ƒï¼šå°‡ç‰©ä»¶æ‹†åˆ†ç‚ºã€ŒèƒŒæ™¯çµ„ã€èˆ‡ã€Œå‰æ™¯çµ„ã€ï¼Œåˆ†åˆ¥è™•ç†ä¸äº’è¸©
                let bgItems = all.filter(i => i.zIndex < this.gridZIndex);
                let fgItems = all.filter(i => i.zIndex >= this.gridZIndex);

                const processGroup = (group) => {
                    const selected = group.filter(i => selIds.includes(i.id));
                    const unselected = group.filter(i => !selIds.includes(i.id));
                    if (selected.length === 0) return group;

                    if (action === 'top') {
                        // ç½®é ‚ï¼šç§»åˆ°è©²ç¾¤çµ„çš„æœ€æœ«ç«¯
                        return [...unselected, ...selected];
                    } else if (action === 'bottom') {
                        // ç½®åº•ï¼šç§»åˆ°è©²ç¾¤çµ„çš„æœ€å‰ç«¯
                        return [...selected, ...unselected];
                    } else if (action === 'up') {
                        // ä¸Šç§»ï¼šåœ¨ç¾¤çµ„å…§èˆ‡å¾Œä¸€å€‹éé¸ä¸­ç‰©ä»¶äº¤æ›
                        let res = [...group];
                        for (let i = res.length - 2; i >= 0; i--) {
                            if (selIds.includes(res[i].id) && !selIds.includes(res[i+1].id)) {
                                [res[i], res[i+1]] = [res[i+1], res[i]];
                            }
                        }
                        return res;
                    } else if (action === 'down') {
                        // ä¸‹ç§»ï¼šåœ¨ç¾¤çµ„å…§èˆ‡å‰ä¸€å€‹éé¸ä¸­ç‰©ä»¶äº¤æ›
                        let res = [...group];
                        for (let i = 1; i < res.length; i++) {
                            if (selIds.includes(res[i].id) && !selIds.includes(res[i-1].id)) {
                                [res[i], res[i-1]] = [res[i-1], res[i]];
                            }
                        }
                        return res;
                    }
                    return group;
                };

                // 3. åˆ†åˆ¥å°å‰æ™¯èˆ‡èƒŒæ™¯é€²è¡Œæ’åºè¨ˆç®—
                bgItems = processGroup(bgItems);
                fgItems = processGroup(fgItems);

                // 4. é‡æ–°åˆ†é…çµ•å° zIndexï¼Œç¢ºä¿é‚Šç•Œä¸è®Š
                bgItems.forEach((item, idx) => { item.zIndex = idx + 1; });
                fgItems.forEach((item, idx) => { item.zIndex = this.gridZIndex + 1 + idx; });

                this.render(); 
                this.saveState();
            },

            // 4. æ›´æ–°æ–°å¢æ–‡å­—é‚è¼¯
            addText() {
                const id = Date.now();
                this.texts.push({
                    id, content: 'Double Click', x: this.outWidth / 2, y: this.outHeight / 2,
                    fontSize: 80, fontFamily: "'Noto Sans TC'", color: '#ffffff',
                    rotation: 0, skewX: 0, skewY: 0, isBold: false, isItalic: false, isUnderlined: false,
                    isVertical: false, strokeColor: '#000000', strokeWidth: 0,
                    zIndex: this.getNextZIndex(), // è‡ªå‹•è¨­ç‚ºæœ€é«˜
                    type: 'text'
                });
                this.selectedTextId = id; this.selectedTextIds = [id];
                this.selectedStickerId = null; this.selectedStickerIds = [];
                this.render(); this.saveState();
            },

            // 5. æ›´æ–°è¤‡è£½æ–‡å­—/è²¼åœ–é‚è¼¯
            duplicateText() {
                let newId = Date.now();
                let hasChange = false;
                
                if (this.selectedTextId) {
                    const t = this.getSelectedText();
                    const newT = JSON.parse(JSON.stringify(t));
                    newT.id = newId; newT.x += 30; newT.y += 30;
                    newT.zIndex = this.getNextZIndex(); // è‡ªå‹•è¨­ç‚ºæœ€é«˜
                    this.texts.push(newT);
                    this.selectedTextId = newId; this.selectedTextIds = [newId];
                    hasChange = true;
                } else if (this.selectedStickerId) {
                    const s = this.getSelectedSticker();
                    const newS = { ...s, id: newId, x: s.x + 30, y: s.y + 30, scaleX: s.scaleX || 1, zIndex: this.getNextZIndex() };
                    this.stickers.push(newS);
                    this.selectedStickerId = newId; this.selectedStickerIds = [newId];
                    hasChange = true;
                }
                if (hasChange) { this.render(); this.saveState(); }
            },
            fixNegativeZ() {
                const all = [...this.texts, ...this.stickers];
                const minZ = Math.min(...all.map(i => i.zIndex || 0));
                if (minZ < 1) {
                    const offset = Math.abs(minZ) + 1;
                    all.forEach(i => i.zIndex = (i.zIndex || 0) + offset);
                }
            },
            toggleText(prop) { 
                // å–å¾—ç•¶å‰é¸ä¸­çš„ä¸»æ–‡å­—ç‰©ä»¶ (æœ€å¾Œé»é¸çš„é‚£ä¸€å€‹)
                const master = this.getSelectedText(); 
                if(!master || master.id === undefined) return; 
                
                // ä»¥ä¸»é¸ä¸­ç‰©ä»¶çš„ç‹€æ…‹é€²è¡Œåè½‰ (Toggle)
                const newValue = !master[prop]; 
                
                // åŒæ­¥æ›´æ–°æ‰€æœ‰è¢«é¸ä¸­çš„æ–‡å­—
                this.selectedTextIds.forEach(id => { 
                    const t = this.texts.find(text => text.id === id); 
                    if(t) t[prop] = newValue; 
                }); 
                
                // ç«‹å³é‡ç¹ªä¸¦å­˜æª”
                this.render(); 
                this.saveState(); 
            },
            getZIndexLabel(zIndex) {
                if (zIndex === undefined) return "";
                if (zIndex < this.gridZIndex) {
                    return `${this.ui.layerBg} ${zIndex}`;
                } else {
                    return `${this.ui.layerFg} ${zIndex - this.gridZIndex}`;
                }
            },
            isAllSelectedInBackground() {
                const selIds = [...this.selectedTextIds, ...this.selectedStickerIds];
                if (selIds.length === 0) return false;
                const all = [...this.texts, ...this.stickers];
                return selIds.every(id => {
                    const item = all.find(i => i.id === id);
                    return item && item.zIndex < this.gridZIndex;
                });
            },
            toggleBackgroundMode() {
                const selIds = [...this.selectedTextIds, ...this.selectedStickerIds];
                if (selIds.length === 0) return;
                const currentlyInBackground = this.isAllSelectedInBackground();
                const all = [...this.texts, ...this.stickers];

                selIds.forEach(id => {
                    const item = all.find(i => i.id === id);
                    if (item) {
                        if (currentlyInBackground) {
                            item.zIndex = this.gridZIndex + 1000; // ç§»è‡³å‰æ™¯é ‚éƒ¨
                        } else {
                            item.zIndex = 1; // ç§»è‡³èƒŒæ™¯åº•éƒ¨
                        }
                    }
                });
                this.normalizeZIndices();
                this.render();
                this.saveState();
            },
            drawImagesLayer(ctx) {
                const siteCounts = {}; this.sites.forEach(s => { siteCounts[s.imgId] = (siteCounts[s.imgId] || 0) + 1; });
                this.images.forEach(img => {
                    const idxs = this.sites.map((s,i)=>s.imgId===img.id?i:-1).filter(i=>i!==-1);
                    if(idxs.length===0) return;
                    const count = siteCounts[img.id] || 0; 
                    const useSeamless = this.mergeInternal && count > 1;

                    ctx.save();
                    ctx.beginPath();
                    if (useSeamless) {
                        const polys = this.getMergedPolygons(img.id);
                        polys.forEach(poly => this.drawPath(ctx, poly, -1, false));
                    } else {
                        idxs.forEach(idx => {
                            const poly = this.voronoi.cellPolygon(idx);
                            if(poly) this.drawPath(ctx, poly, idx, false);
                        });
                    }
                    ctx.clip(); 

                    if (!img.isEmpty) {
                        let cx=0, cy=0; idxs.forEach(i => { cx+=this.sites[i].x; cy+=this.sites[i].y; }); cx /= idxs.length; cy /= idxs.length;
                        ctx.translate(cx + img.x, cy + img.y); ctx.rotate(img.rotation * Math.PI/180); ctx.scale(img.scale * (img.scaleX||1), img.scale);
                        if(img.obj) ctx.drawImage(img.obj, -img.obj.width/2, -img.obj.height/2);
                        else { ctx.fillStyle = '#222'; ctx.fillRect(-100, -50, 200, 100); }
                    } else {
                         if (this.mode !== 'export' && (this.showBorders || img.id === this.selectedImgId)) {
                             ctx.fillStyle = 'rgba(255, 255, 255, 0.1)'; ctx.fill();
                         }
                    }
                    ctx.setTransform(1, 0, 0, 1, 0, 0); 
                    if(this.imgBorder && this.imgBorderWidth > 0 && !img.isEmpty) {
                        ctx.beginPath();
                        if (useSeamless) {
                            const polys = this.getMergedPolygons(img.id);
                            polys.forEach(poly => this.drawPath(ctx, poly, -1, false));
                        } else {
                            idxs.forEach(idx => {
                                const poly = this.voronoi.cellPolygon(idx);
                                if(poly) this.drawPath(ctx, poly, idx, false);
                            });
                        }
                        ctx.lineWidth = this.imgBorderWidth * 2; ctx.strokeStyle = this.hexToRgba(this.imgBorderColor, this.imgBorderAlpha); ctx.stroke();
                    }
                    ctx.restore();
                });
            },

            // ç¹ªè£½é€æ˜é–“è· (ä¿®æ­£ï¼šå‚³å…¥ ctx)
            drawGapLayer(ctx) {
                const siteCounts = {}; this.sites.forEach(s => { siteCounts[s.imgId] = (siteCounts[s.imgId] || 0) + 1; });
                ctx.save();
                ctx.globalCompositeOperation = 'destination-out';
                ctx.lineWidth = this.gap;
                ctx.lineCap = 'round'; ctx.lineJoin = 'round';
                ctx.beginPath();
                for(let i=0; i<this.sites.length; i++) {
                    const s = this.sites[i];
                    const enableMerge = this.mergeInternal && (siteCounts[s.imgId] > 1);
                    this.traceExternalOnly(ctx, i, enableMerge);
                }
                ctx.stroke();
                ctx.restore();
            },

        }
    });
</script>
</body>
</html>